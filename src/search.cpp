/*
  Stockfish, a UCI chess playing engine derived from Glaurung 2.1
  Copyright (C) 2004-2025 The Stockfish developers (see AUTHORS file)

  Stockfish is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  Stockfish is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "search.h"

#include <algorithm>
#include <array>
#include <atomic>
#include <cassert>
#include <chrono>
#include <cmath>
#include <cstdint>
#include <cstdlib>
#include <initializer_list>
#include <iostream>
#include <list>
#include <ratio>
#include <string>
#include <utility>

#include "evaluate.h"
#include "history.h"
#include "misc.h"
#include "movegen.h"
#include "movepick.h"
#include "nnue/network.h"
#include "nnue/nnue_accumulator.h"
#include "nnue/nnue_common.h"
#include "position.h"
#include "syzygy/tbprobe.h"
#include "thread.h"
#include "timeman.h"
#include "tt.h"
#include "uci.h"
#include "ucioption.h"

namespace Stockfish {

int savedCaptureHistory[16*64*8] = {
     -514, -698, -812, -412, -840, -1027, -826, -863, -902, -988, -494, -499, -629, -823, -646, -696, -577, -873, -610, -561, -195, -754, -861, -689, -390, -1022, -588, -865, -524, -700, -491, -603, -598, -310, -661, -828, -553, -528, -733, -772, -736, -625, -611, -873, -510, -796, -438, -772, -306, -574, -551, -699, -414, -997, -517, -72, -573, -463, -571, -466, -933, -694, -770, -652, -514, -654, -497, -517, -434, -809, -1075, -390, -867, -845, -425, -970, -581, -931, -917, -317, -628, -696, -528, -672, -645, -464, -452, -498, -470, -653, -589, -448, -959, -699, -731, -277, -687, -840, -888, -878, -729, -684, -590, -632, -639, -452, -545, -650, -908, -728, -712, -673, -964, -912, -978, -981, -622, -711, -730, -547, -778, -792, -432, -854, -850, -867, -809, -838, -84, -673, -800, -735, -350, -712, -338, -643, -745, -902, -728, -718, -346, -433, -599, -672, -562, -1025, -653, -446, -494, -429, -552, -795, -805, -606, -846, -474, -676, -638, -396, -965, -361, -456, -657, -518, -878, -957, -763, -642, -748, -477, -602, -735, -657, -913, -337, -489, -840, -476, -859, -892, -815, -487, -739, -805, -364, -374, -366, -495, -544, -699, -696, -427, -693, -945, -609, -599, -628, -366, -228, -474, -864, -767, -770, -673, -590, -650, -607, -548, -591, -800, -751, -284, -861, -777, -753, -780, -725, -870, -680, -899, -581, -811, -665, -878, -443, -622, -696, -682, -580, -477, -686, -1049, -810, -841, -478, -657, -959, -769, -832, -597, -427, -467, -849, -793, -567, -559, -455, -626, -429, -723, -537, -563, -542, -716, -632, -863, -791, -277, -543, -537, -927, -511, -741, -577, -589, -340, -698, -642, -740, -679, -831, -836, -618, -1030, -803, -750, -956, -581, -402, -727, -682, -867, -777, -708, -621, -732, -753, -787, -576, -939, -944, -900, -517, -803, -898, -775, -722, -705, -1004, -768, -649, -647, -833, -423, -519, -791, -847, -690, -405, -1156, -739, -808, -1125, -438, -680, -915, -368, -887, -724, -456, -931, -761, -663, -1001, -474, -890, -559, -899, -509, -708, -855, -665, -510, -607, -1077, -443, -599, -838, -377, -558, -570, -511, -562, -541, -1195, -789, -595, -600, -346, -818, -628, -834, -379, -592, -898, -795, -659, -374, -662, -762, -373, -575, -1091, -764, -853, -865, -496, -635, -384, -780, -989, -528, -622, -617, -252, -674, -316, -433, -827, -679, -607, -703, -735, -803, -312, -833, -730, -483, -825, -620, -587, -732, -706, -687, -783, -719, -952, -623, -412, -877, -579, -547, -661, -653, -598, -431, -628, -836, -1009, -697, -539, -685, -647, -733, -493, -631, -455, -648, -659, -1012, -489, -395, -450, -883, -1023, -695, -1273, -800, -814, -781, -527, -568, -602, -818, -525, -934, -705, -889, -839, -420, -776, -819, -610, -508, -801, -997, -629, -768, -539, -700, -727, -682, -400, -1115, -456, -366, -772, -604, -639, -688, -581, -380, -320, -802, -505, -993, -820, -411, -492, -794, -952, -546, -863, -768, -577, -700, -983, -576, -414, -514, -400, -366, -584, -487, -661, -931, -975, -453, -377, -640, -730, -743, -846, -932, -469, -558, -654, -744, -482, -1079, -634, -409, -627, -391, -780, -474, -808, -643, -756, -483, -555, -846, -315, -696, -687, -845, -725, -537, -488, -649, -431, -627, -511, -703, -745, -535, -726, -611, -548, -524, -574, -1052, -706, -232, -845, -645, -649, -397, -827, -853, -714, -327, -875, -558, -532, -634, -712, -674, -432, -835, -740, -958, -928, -441, -712, -413, -818, -557, -607, -717, -1111, -623, -698, -969, -590, -146, -650, -423, -437, -526, -727, -464, -725, -678, -812, -655, -471, -764, -842, -537, -673, -738, -659, -275, -781, -809, -799, -609, -741, -779, -694, -760, -743, -950, -713, -595, -689, -740, -609, -979, -853, -366, -520, -904, -482, -833, -669, -935, -205, -454, -518, -508, -792, -548, -789, -459, -824, -408, -338, -867, -459, -618, -146, -874, -1022, -718, -731, -644, -1006, -458, -670, -422, -456, -825, -1210, -543, -635, -682, -664, -586, -632, -2446, 771, 3214, 6412, 10168, -728, -404, -673, 3150, 10392, 10571, 9943, 10654, -707, -723, -547, 673, 9571, 5769, 7795, 10526, -812, -499, -894, -1481, 9943, 7517, 7792, 9992, -529, -344, -571, 319, 10607, 7444, 7874, 9869, -700, -460, -888, -7528, 4036, 6474, 4098, 10445, -638, -572, -628, 1079, 10049, 2279, 8692, 9953, -792, -693, -466, -7607, 10506, 10566, 1259, 9579, -413, -521, -854, -530, 5798, 62, 8444, 5589, -523, -481, -530, 5512, 10076, 10320, 10544, 7639, -802, -787, -905, -2331, 10624, 10588, 8425, 9858, -762, -815, -722, 8078, 4247, 10288, 10601, 10354, -892, -869, -417, 10514, 10609, 9908, 10670, 10353, -855, -702, -693, 3430, 6733, 8657, 6616, 10330, -791, -755, -874, 10297, 8357, 9890, -603, 10625, -632, -558, -925, -6972, -2347, 3135, 10607, 10390, -491, -831, -574, -2154, 7720, 7959, 10064, 10518, -799, -621, -850, 2977, -2440, 803, 9206, 10544, -389, -612, -628, 5926, 10596, 10503, 10295, 10596, -241, -937, -497, -4515, 7864, 7287, 9393, 10678, -220, -1014, -516, 7527, 10625, 10521, 10685, 10359, -505, -672, -627, 7023, 10479, 10566, 7825, 10670, -543, -600, -709, 965, 7656, 10375, 10332, 10409, -645, -679, -963, -1850, 9206, 7618, 1022, 5264, -697, -653, -598, -6741, 10522, 9733, 5285, -865, -867, -663, 3204, -2519, 10655, 9224, 9295, 10678, -982, -692, -2206, 7811, 5773, 10245, 9842, 10558, -316, -899, -1917, 5824, 10127, 8299, 7931, 10477, -861, -599, 4546, 9995, 3049, 7856, 1640, 7733, -625, -426, -288, -3407, 3370, 10397, 9208, 10467, -489, -895, 2765, 4643, 9294, 8372, -653, 9849, -469, -980, 324, 799, 5415, -631, 1338, -361, -515, -526, -1121, 695, -511, -638, 6864, -838, -292, -596, -197, 9066, -622, 612, 6528, 3525, -842, -690, -778, 4553, 7099, 5972, 5121, 9697, -533, -611, -730, 7287, 10685, 10502, 1144, 10530, -399, -959, -623, -4881, 8930, -986, 836, 10626, -852, -639, -711, 10071, 1131, -789, 9297, 679, -335, -769, -552, 4460, -2062, 9107, 8522, -816, -796, -759, -547, -7033, -748, -313, 2125, -1004, -816, -538, -570, -934, -612, -619, 3162, 798, -210, -770, -2560, -521, -6420, -299, 5205, -394, -667, -592, -7359, -463, -1218, -2424, -13, 435, -777, -399, -681, -450, -744, -1087, 8491, 10552, -423, -321, -1214, -777, -976, 2333, 1381, -680, -968, -1078, -3392, -1074, -535, 2721, 10355, -501, -601, -943, -3011, -556, -3888, -469, -553, -332, -378, -594, -738, -850, -705, -496, 8964, -788, -563, -397, -265, -581, 8563, 3265, 5224, 8763, -307, -505, -1039, -499, -761, -4090, 3170, 10611, -543, -516, -624, -1030, 617, 175, 146, -1878, -623, -628, -677, -859, -1425, -7243, 9299, 3189, -872, -739, -626, -503, -3146, -939, 7773, 2565, -558, -1003, -510, -546, -2417, -70, 9896, 10345, -682, -530, -781, -724, -491, -483, 2843, 10561, -663, -716, -751, -763, -629, -524, -499, 8336, -783, -446, -621, -5898, 10617, 4454, 7284, 10506, -555, -807, -557, -5758, 2173, 10355, 10692, 4657, -667, -979, -249, -1463, 9781, 2384, 5697, 10549, -652, -463, -543, 5293, -1543, 616, 8145, 10586, -522, -871, -833, 2699, 4427, 9623, 10124, 5732, -618, -606, -533, -2152, 9278, 10610, 745, 10611, -338, -550, -527, 900, -12, 7864, 1381, 10593, -603, -648, -294, -1139, 10596, 9460, -191, 10555, -721, -662, -296, -1573, 6581, 9670, 8531, 10661, -676, -838, -732, -1392, 6811, 3444, 1669, 9789, -782, -779, -531, -1263, 10458, 10655, -633, 10338, -696, -782, -1008, 5082, 6597, 8048, 490, 10533, -874, -755, -972, -5504, 7931, 8587, 2121, 10655, -911, -736, -358, 5727, 9830, 10326, 8692, 10575, -278, -641, -902, 9541, 5760, 8674, 4738, -1128, -737, -654, -876, 3541, -1687, 10664, -582, 16, -738, -728, -758, -5091, 229, 9718, 8768, 7847, -768, -826, -799, -8907, 5442, 10448, 7540, 10623, -778, -535, -759, 2984, 7722, 7748, 7443, 6725, -845, -947, -741, 1449, 6800, 9442, 8291, 10611, -549, -687, -839, 7517, 10527, 2786, 10157, 10460, -615, -534, -736, 8582, 10378, 10611, 4534, 10275, -680, -195, -858, 5124, 7543, 9847, 1912, 10509, -1111, -932, -670, -4187, 6307, 10183, 5537, 10538, -1073, -542, -664, -2441, 10152, 9615, 10600, 10628, -687, -624, -686, -1548, 10536, 10124, 5460, 10392, -402, -779, -533, -8763, 2841, 10470, 8593, 10452, -474, -777, -558, -3168, 3442, 8087, 10513, 10692, -614, -972, -1112, 3052, 4180, 6538, 8917, 10493, -778, -517, -586, 8348, 7105, 8555, 42, 10574, -795, -892, -361, 7477, 9075, 8700, 9933, 10288, -758, -681, -832, -2592, 8478, 8440, -129, 10326, -755, -595, -324, -9557, 1647, -1421, 8959, 3844, -645, -793, -741, -9381, -1051, 8635, 1408, 10692, -687, -1027, -878, -1345, -8096, -2918, 9132, 10417, -629, -725, -583, -2244, 4602, 6609, 8850, 10685, -612, -705, -485, 2426, -2308, 1219, 5457, 10497, -604, -1099, -552, -6909, 3588, 10332, 3358, 10457, -704, -632, -703, 6560, 7550, 1759, 858, 9347, -407, -534, -481, -4770, -482, -200, -387, 5866, -648, -623, -195, -7091, -1046, 4199, 5394, 2826, -833, -738, -636, 4909, -512, 10646, 8532, 8067, -684, -472, -495, -325, 10610, 8999, 8733, 10548, -902, -643, -451, -8980, -79, 3161, 9734, 10251, -1167, -619, -779, -2114, -6912, -6219, 2978, 10483, -693, -612, -627, 3356, 7916, -3110, 10580, 9294, -675, -436, -695, -479, 241, 86, 8409, 5681, -522, -410, -469, 2486, 8859, -554, 3527, 1386, -255, -558, -623, -496, -665, 3444, 4093, 6831, -860, -849, -475, -569, 5941, -290, 3769, 1769, -589, -745, -534, -626, -5417, 1882, 8184, 9494, -392, -603, -674, -447, -468, 8577, 9729, 10636, -732, -671, -455, -329, -5204, -2444, 9818, 8839, -662, -683, -804, -1039, 3856, -7121, 6755, 1372, -1028, -730, -859, -832, -5511, -806, 4977, -775, -509, -821, -380, -561, -278, 175, 9063, -758, -870, -489, -547, -862, -584, 4729, 8510, 9436, -733, -662, -740, -434, 407, -288, 4710, 995, -899, -913, -792, -466, 2110, -3658, 5092, 4946, -269, -777, -499, -877, -6136, 5480, 6954, 3243, -737, -791, -840, -487, -2544, -685, 4180, 10054, -790, -675, -561, -876, -4336, -4425, 10452, 10497, -550, -675, -406, -598, -725, -448, -496, 1101, -680, -668, -981, -557, 1351, 8702, 8792, 10595, -845, -460, -670, 4269, 8879, 2836, 371, 4477, -519, -318, -527, 10566, 10642, 10610, 10633, 10660, -572, -739, -562, -10, 10685, 9309, 9905, 10596, -568, -560, -271, 10440, 8849, 10032, 9454, 10633, -513, -630, -491, 9899, 9595, 7075, 7750, 10564, -774, -410, -562, 7879, 4849, 4571, 8240, 10625, -875, -710, -849, 8374, 10582, 8003, 3319, 10640, -828, -549, -762, -373, 10601, 4158, 6646, 9259, -479, -854, -668, -5979, 6998, 10415, 9361, 10590, -635, -447, -756, 5089, 6394, 3127, 2842, 10618, -646, -915, -834, 9662, 4903, 10562, 7975, 10685, -881, -453, -818, 6538, 8244, 9982, 8924, 10678, -172, -539, -526, 7059, 8319, 10300, 6971, 10568, -852, -741, -967, 10313, 10464, 10548, 6315, 10638, -783, -545, -702, -213, 9601, 7762, -6892, 4690, -750, -668, -629, -3183, 5711, 10371, -811, 8638, -488, -614, -534, 9566, -7334, 2889, 6006, 9771, -249, -606, -973, 6310, 283, -5920, 2406, 10447, -415, -496, -212, -1818, 7044, 6716, 10344, 10670, -860, -776, -627, 4633, 8614, 9261, 9604, 10062, -510, -803, -713, 8209, 5377, 10640, 3991, 10455, -677, -784, -1085, 2793, 9943, 9207, 5804, 8899, -612, -580, -721, 9413, 3879, 3783, 10618, 10393, -668, -703, -661, -2633, 8135, 3430, 8933, 10623, -556, -799, -709, 6301, 8047, 346, 10408, 10335, -651, -760, -438, 3913, 9639, 5263, 9336, 10560, -651, -510, -571, -4768, 3512, -1169, 4876, 10552, -264, -715, -782, -601, 9618, 5800, 9213, 10513, -532, -709, -905, 5528, 10303, 9517, 9737, 10537, -668, -357, -564, 5867, 5232, 4388, 2192, 5442, -571, -626, -643, 7730, 5287, -1206, 6362, 10678, -397, -525, -408, 6925, 6770, 9034, 2229, 9673, -718, -742, -590, -10278, 9755, 10399, 10670, 10551, -641, -490, -299, -6668, -4851, 4091, 1085, 10315, -795, -900, -877, -1704, 2842, 9981, 6583, 4475, -816, -873, -611, -5276, -6754, -4338, 7678, 10146, -702, -612, -772, -7769, 5192, 6217, 8640, 5245, -439, -883, -358, 4884, -8032, 154, -73, 10589, -576, -318, -630, -3346, 6092, -4414, 4411, 9297, -849, -812, -670, -10685, -2368, 1558, -2128, 8374, -1017, -967, -563, -10386, 2828, 7738, 5939, 2793, -727, -598, -509, -5545, 3523, 1394, 2980, 10506, -667, -1113, -754, 5756, 10670, 8063, 3544, 10655, -399, -690, -747, 7216, -5569, 4169, 2627, 10563, -266, -755, -679, -10183, -4249, 8617, 1935, 10685, -903, -605, -886, -2536, 9071, 10424, 9376, 10671, -880, -740, -763, -3374, -6490, 3243, 8496, 10685, -473, -646, -796, -9984, 295, 10393, 8888, 988, -727, -679, -817, -636, -789, 1802, 2485, 10574, -702, -656, -598, -1166, -10314, -6930, 10360, 3522, -802, -390, -402, -878, 4526, 255, 4260, 10266, -378, -726, -418, -176, -5586, 7879, 7658, 10566, -868, -644, -784, -799, -5185, 2329, 10073, 10600, -522, -1015, -524, -874, -6974, -4195, 2891, 9296, -490, -883, -753, -521, -6076, -424, 2474, -321, -530, -779, -906, -573, -771, 2047, 68, 3029, -898, -626, -504, -676, 920, 606, 10467, 3765, -889, -807, -991, -639, 2734, 10308, 6810, -126, -630, -927, -528, -240, 8813, 2793, 9168, 9785, -764, -877, -728, -630, -3516, -3078, 10360, 10345, -738, -691, -728, -445, 577, 1034, 10294, 10613, -716, -907, -627, -666, -868, 9111, 10613, 10590, -652, -756, -628, -792, 2951, 5467, 9343, 10685, -729, -507, -479, -680, 1412, -677, 2471, -1922, -748, -836, -767, -5933, 7040, 7687, 10536, 10692, -825, -602, -554, 77, 8047, 3017, 7794, 9508, -591, -665, -710, 949, 9831, 5170, -2901, 8232, -363, -436, -687, 577, 699, 374, 8944, 10564, -698, -549, -406, -618, 8026, -1508, 7266, 10414, -352, -720, -793, 10186, 5828, 10482, 10670, 10692, -405, -887, -758, 8327, 1320, 4072, -601, 10165, -433, -523, -741, -3432, 9047, 2434, 8428, 10661, -847, -537, -944, -3977, 1539, 10640, 10633, 9983, -581, -585, -982, 3872, 4427, -4190, -265, 5962, -717, -575, -546, 113, 2274, 7772, 50, 8123, -633, -132, -625, 1371, 7839, 1734, 2264, 4005, -837, -829, -830, 8920, 9838, 10122, 9561, 9392, -296, -566, -539, -2561, 8989, 6230, 8162, 10100, -738, -503, -540, -1059, 494, 3214, 1264, 6914, -536, -533, -385, 6342, -615, 9604, -813, 781, -373, -719, -926, -4031, -899, 10012, 9871, 10416, -590, -979, -813, -6926, -43, -2405, 6798, 10558, -890, -476, -555, -1272, 6373, 9177, 8478, 8443, -623, -843, -934, 3824, 5823, -283, 6180, 7129, -562, -610, -644, 7118, -4485, 6638, 4606, 4690, -464, -787, -767, -6626, 4211, -2692, -2934, 10040, -725, -454, -813, 8992, 1553, 1002, -739, 7514, -166, -528, -653, 4475, 4573, -976, 10222, 10493, -888, -660, -723, -1041, 5269, 9313, 10685, 9549, -814, -538, -328, -5129, 4408, 10164, 1706, 10416, -600, -595, -721, -1128, -3210, 9275, 7048, 10685, -517, -561, -821, 857, -3762, 1330, 8119, 8233, -757, -184, -800, 2474, 5606, 1784, 9662, 10228, -539, -920, -1040, -2512, 194, -2874, 514, 10316, -485, -967, -817, 76, -4026, 2250, -909, 10685, -633, -513, -558, 8034, 7447, 8166, -425, 1840, -121, -449, -250, -10577, -1119, 6925, 10562, 8935, -791, -789, -634, -9563, 2687, -5812, 10469, 10197, -279, -711, -659, -3572, -784, -10, 10620, 10620, -1142, -866, -422, 7681, 3302, -974, 4623, 7294, -579, -712, -739, 5870, -926, -5505, 3304, 10581, -609, -483, -829, 83, -7848, 634, -3362, 10446, -645, -908, -611, 101, -7626, -6056, -613, 6751, -937, -661, -316, -5633, -5547, 8051, 7679, 7841, -697, -683, -746, -8635, 2789, -644, 8825, 9685, -288, -756, -513, 2344, 733, 200, 8134, 10300, -902, -640, -956, 7262, 8623, -2798, 6948, 10196, -681, -689, -328, -8127, -7729, -4713, 4183, 10497, -871, -549, -540, -528, -2396, -8593, 1046, 10280, -329, -858, -442, -1536, 2871, 798, 3097, 4756, -786, -369, -740, -3078, 4326, 960, -2829, -884, -467, -494, -718, -2175, -251, -328, 4063, -500, -343, -352, -377, -651, -638, 582, 10209, 10611, -582, -540, -424, -499, 1702, -698, 5828, 1716, -748, -810, -602, -850, -1729, -940, -3625, 10394, -444, -707, -895, -723, -788, -5982, -931, 10692, -461, -875, -640, -647, -1627, -328, 6654, 9867, -529, -903, -685, -690, 2809, -5712, 1599, 9238, -938, -615, -704, -836, -3042, -406, 9652, -612, -781, -902, -635, -348, -636, 2224, 10692, -673, -786, -907, -622, -731, -4299, 9924, 10378, 10530, -763, -696, -697, -794, -2889, 1729, 6955, 10583, -745, -854, -886, -962, 2850, 9897, 6445, 10559, -499, -647, -629, -948, -1793, -2375, 9170, 10670, -864, -882, -567, -849, 6211, 7612, 10608, 10685, -344, -693, -549, -420, -10015, 210, 10123, 10493, -768, -614, -744, -559, -482, 1215, -936, 6629, -512, -712, -998, -647, 2850, 2362, 1622, 10583, -596, -420, -559, -3480, 7677, 7775, 5105, 9265, -753, -355, -571, -2677, 10102, 8619, 10039, 8372, -528, -565, -1039, 9750, 10590, 10518, 10481, 7451, -488, -125, -630, 6701, -2844, 10463, 7184, 10501, -881, -757, -907, 10619, 10578, 10670, 10509, 10504, -466, -646, -561, 8520, 2747, 8304, 2362, 10625, -566, -597, -630, -1396, 4140, 10159, 7978, 10524, -685, -345, -995, -3452, -573, 10415, -1077, 10678, -664, -795, -381, -4305, -3173, 9507, 5209, 4420, -675, -572, -910, 5604, 9388, 4978, 7194, 2799, -543, -494, -604, -3225, 10206, 7772, 5980, 10199, -762, -642, -700, 7619, 10595, 9935, 3159, 10351, -1159, -882, -663, -4575, 7381, 10655, 9676, 10636, -585, -782, -631, 1860, 8224, 10486, 6027, 10678, -521, -589, -726, -1769, 9979, -441, 4488, 4557, -701, -681, -392, -702, -3444, 8894, -255, 427, -735, -975, -450, 1663, 7680, 10692, 10578, 10572, -508, -834, -762, -3430, 6410, 8606, 9372, 6467, -514, -487, -663, -492, 9196, 10089, 9272, 10685, -853, -535, -738, 29, 8628, 10353, 8297, 8428, -654, -678, -617, 10543, 6061, 9819, 9592, 10422, -602, -503, -629, 1274, 7138, 9602, 6182, 9817, -836, -735, -605, 1694, 8827, 10685, 6886, 3679, -788, -681, -484, -6120, 6739, -5028, 4744, 10256, -538, -589, -603, 3346, 1690, 10608, 5386, 10331, -827, -508, -552, -3805, 923, 10305, 8467, 3653, -391, -601, -399, 5540, 8269, 9791, 936, 6148, -885, -1144, -899, 5220, 10591, -2867, 5763, 1236, -774, -722, -702, 10157, 9797, 9603, 9869, 10265, -932, -334, -883, 372, 5093, 10258, 4369, 1799, -431, -430, -463, -1268, 6491, 2082, 10260, 5010, -848, -760, -555, 815, 9635, 5515, 10222, 10216, -508, -817, -570, -5107, -97, 10655, 10692, 2544, -799, -999, -620, -2420, -7834, -1335, 3533, 9, -865, -1133, -481, 4759, -352, 9942, 10127, 1851, -487, -463, -258, 8383, 1221, 2825, 7212, 7289, -752, -836, -491, -706, -3263, 10565, 6486, 8272, -443, -496, -860, 10355, 2738, 9374, 88, -4861, -506, -907, -363, 516, -6366, 247, -2809, -515, -898, -556, -617, 442, -668, 10352, 10540, 8814, -754, -679, -577, 2863, 8105, 2404, 10678, 5447, -801, -775, -564, 154, 4682, 6765, 3674, -3839, -546, -634, -497, -2943, 4710, 9277, 10520, 2487, -717, -539, -578, 3073, 1599, 3487, 3813, 2222, -536, -470, -734, 2793, 6489, 2580, 5227, 6737, -438, -733, -464, 9507, 1101, -2804, 6164, 8169, -660, -584, -456, 4703, 9424, 10685, 9958, -3974, -612, -721, -625, 7129, 10187, -810, 9360, -3211, -472, -861, -317, -815, 9382, 8980, 5573, 1086, -743, -702, -913, -584, 6838, -806, 7490, 6044, -376, -1056, -845, -809, -762, 10141, 7547, 5089, -586, -662, -605, -441, -293, 2098, 7563, 7104, -669, -771, -609, -642, 10627, 2102, 10670, 9288, -815, -684, -781, -503, -846, 3079, -3927, -5161, -639, -590, -795, -708, 8171, -289, 10655, -4634, -530, -622, -892, -419, -750, -692, 10551, -289, -1048, -769, -750, -612, -532, -210, 3156, -169, -589, -447, -627, -986, -834, -927, 8353, 10293, -914, -815, -755, -190, -1586, -3, 7670, 3522, -444, -403, -674, -475, 9579, 5718, 10606, 10364, -727, -669, -502, -755, -355, 6100, 10685, 10685, -226, -619, -709, -621, -5451, 4614, 10158, 10243, -313, -777, -593, -667, -621, 1354, 274, 10042, -1077, -366, -761, -703, 5814, 2130, 8626, 10367, -983, -920, -622, -463, 3010, 7065, 1201, -587, -751, -366, -591, 2618, 4062, 10655, 10184, 10376, -507, -639, -514, -1550, 5856, 8875, 10491, 10555, -606, -820, -751, 2265, -683, 10528, 10573, 10518, -471, -735, -470, -1247, 7869, 7044, 10692, 10541, -652, -542, -608, 10649, 10692, 10522, 6315, 10665, -490, -731, -492, -6203, 6782, 10469, 10525, 10633, -637, -596, -687, -3233, 9722, 10692, 5383, 10640, -537, -858, -836, -163, -809, 9750, -715, -396, -848, -571, -755, -424, -89, 2847, -528, -301, -771, -520, -497, 5030, 3605, 9568, 10480, 10465, -534, -339, -315, 10090, 3726, 10530, 10158, 9449, -688, -696, -538, 3292, 6195, 10616, 8828, 6968, -804, -728, -655, -1017, 7587, 3296, 1567, 10378, -512, -761, -559, -512, -340, 3455, 1423, 5750, -486, -897, -679, -528, -840, 10572, 425, 9330, -596, -388, -739, -723, -913, -944, -872, -380, -687, -1054, -468, 2680, 10412, 8881, -752, -796, -901, -632, -590, -3517, 1980, 324, -507, -160, -605, -834, -727, 5044, 5796, -229, 2035, 4991, -217, -517, -313, -2488, 4199, -358, 1040, 4395, -655, -619, -707, 4319, -748, 2047, 194, 9100, -551, -703, -614, -552, 3603, 9799, -253, 3657, -654, -839, -542, -845, -905, -1093, -610, 10478, -368, -661, -635, 5386, 711, -625, -777, -679, -635, -690, -586, 225, -639, -681, -816, -589, -522, -265, -908, 164, -419, 109, -303, -171, -686, -640, -674, -1857, -429, -595, -618, -520, -436, -693, -505, -868, -683, -534, -759, -794, -584, -485, -475, 511, -774, -403, -584, -368, -1017, -903, -427, 2940, -823, -545, -753, -827, -1123, -389, -804, -750, -923, -454, -681, -602, -471, -449, -476, -624, -592, -386, -958, -612, -605, -482, -357, -22, -797, -397, -518, -559, -618, -596, -600, -872, -867, -751, -792, -506, -523, -483, -1092, -801, -629, -461, -749, -718, -437, -645, -335, -780, -809, -853, -662, -637, -491, -684, -711, -821, -623, -625, -505, -899, -488, -931, -554, -597, -332, -776, -633, -660, -826, -590, -665, -964, -1033, -878, -865, -631, -1018, -610, -343, -597, -911, -783, -466, -761, -602, -545, -501, -449, -648, -626, -822, -742, -643, -903, -358, -848, -760, -469, -751, -683, -621, -891, -838, -679, -782, -815, -502, -619, -649, -919, -278, -1017, -302, -935, -638, -683, -497, -1042, -733, -407, -806, -971, -708, -882, -436, -608, -847, -716, -964, -704, -728, -645, -840, -707, -835, -938, -572, -624, -798, -771, -797, -851, -836, -497, -500, -415, -525, -834, -697, -705, -645, -765, -869, -856, -697, -525, -607, -686, -208, -808, -630, -787, -657, -310, -844, -791, -270, -769, -638, -732, -559, -683, -500, -905, -782, -778, -428, -530, -488, -903, -726, -597, -762, -566, -715, -727, -380, -632, -675, -941, -1117, -743, -655, -694, -539, -727, -592, -510, -581, -793, -672, -744, -469, -856, -473, -603, -659, -320, -153, -525, -510, -500, -375, -939, -786, -336, -697, -444, -585, -531, -927, -375, -583, -775, -774, -686, -637, -569, -663, -798, -745, -744, -543, -706, -724, -387, -926, -733, -618, -878, -882, -630, -618, -634, -477, -807, -620, -596, -352, -753, -716, -827, -928, -868, -602, -882, -1044, -955, -676, -562, -346, -532, -527, -615, -643, -642, -544, -511, -869, -272, -558, -806, -541, -578, -556, -492, -358, -421, -778, -834, -751, -636, -397, -869, -918, -601, -851, -1018, -281, -911, -800, -685, -715, -660, -927, -530, -667, -462, -863, -667, -573, -359, -696, -384, -765, -603, -324, -944, -499, -965, -663, -777, -737, -404, -282, -691, -627, -916, -620, -766, -823, -973, -633, -754, -419, -706, -249, -422, -659, -480, -535, -793, -668, -565, -620, -736, -294, -597, -746, -898, -633, -837, -813, -747, -740, -859, -981, -602, -755, -864, -665, -561, -513, -325, -927, -757, -704, -519, -702, -868, -669, -401, -287, -1007, -555, -441, -730, -629, -850, -878, -572, -759, -761, -475, -613, -979, -645, -788, -579, -400, -421, -829, -475, -944, -559, -942, -714, -406, -698, -850, -708, -599, -646, -478, -488, -819, -462, -586, -553, -607, -475, -319, -568, -649, -592, -790, -573, -715, -806, -492, -515, -540, -575, -749, -938, -459, -668, -769, -767, -642, -726, -577, -654, -570, -265, -721, -740, -552, -714, -732, -526, -460, -508, -539, -630, -565, -606, -654, -850, -848, -794, -206, -853, -777, -718, -442, -450, -696, -1009, -724, -700, -669, -740, -484, -764, -569, -611, -659, -702, -551, -886, -454, -536, -443, -740, -609, -296, -711, -747, -705, -579, -798, -687, -761, -636, -372, -893, -620, -792, -827, -653, -790, -426, -364, -335, -479, -595, -424, -943, -447, -701, -946, -292, -982, -711, -766, -759, -669, -547, -862, -792, -421, -501, -548, -377, -718, -553, -964, -858, -593, -973, -745, -647, -380, -623, -351, -506, -555, -609, -956, -748, -719, -732, -1008, -721, -315, -957, -510, -1118, -454, -575, -619, -632, -533, -629, -565, -538, -702, -1040, -640, -548, -1038, -291, -797, -624, -844, -643, -361, -570, -641, -507, -704, -497, -607, -513, -782, -817, -617, -864, -574, -613, -524, -628, -411, -996, -466, -731, -688, -522, -322, -630, -504, -725, -759, -395, -259, -469, -482, -1049, -763, -547, -622, -586, -348, -654, -761, -720, -843, -582, -801, -457, -802, -313, -489, -795, -751, -837, -334, -910, -738, -936, -404, -688, -744, -497, -1074, -664, -187, -1008, -677, -605, -412, -724, -796, -697, -530, -865, -1136, -499, -946, -603, -657, -920, -678, -711, -820, -738, -770, -452, -582, -318, -724, -1005, -544, -548, -688, -517, -655, -420, -410, -619, -344, -562, -597, -581, -746, -868, -408, -428, -661, -632, -288, -538, -898, -362, -694, -633, -667, -296, -561, -538, -815, -683, -478, -514, -822, -1018, -749, -770, -731, -681, -501, -733, -601, -815, -686, -553, -472, -661, -478, -864, -473, -820, -595, -735, -489, -765, -654, -679, -324, -882, -763, -624, -890, -487, -631, -666, -952, -639, -745, -827, -593, -638, -1188, -999, -761, -1011, -483, -472, -704, -856, -555, -412, -615, -446, -1099, -543, -601, -847, -668, -343, -730, -831, -720, -565, -284, -719, -804, -598, -684, -612, -819, -578, -818, -567, -742, -336, -867, -666, -615, -926, -896, -770, -224, -711, -917, -161, -664, -511, -483, -846, -621, -431, -592, -108, -655, -609, -526, -663, -791, -573, -807, -744, -792, -886, -555, -789, -581, -699, -509, -783, -808, -726, -482, -903, -827, -475, -435, -821, -873, -593, -675, -571, -871, -118, -749, -760, -204, -808, -616, -616, -478, -432, -516, -333, -931, -811, -405, -934, -379, -505, -772, -1145, -912, -699, -853, -436, -247, -786, -623, -682, -836, -733, -654, -851, -679, -832, -929, -477, -486, -621, -611, -559, -778, -647, -574, -412, -693, -873, -607, -767, -672, -562, -249, -692, -995, -175, -400, -605, -501, -594, -363, -565, -524, -755, -598, -230, -697, -873, -611, -595, -929, -912, -557, -672, -626, -639, -1057, -575, -670, -385, -802, -714, -629, -359, -772, -881, -953, -702, -549, -283, -580, -472, -749, -315, -486, -639, -619, -679, -396, -956, -371, -816, -521, -446, -1073, -958, -598, -569, -770, -872, -754, -682, -754, -1204, -961, -824, -518, -666, -715, -384, -972, -789, -994, -644, -610, -915, -403, -707, -628, -550, -786, -466, -350, -600, -751, -1284, -471, -712, -421, -667, -182, -846, -506, -713, -882, -617, -692, -498, -590, -909, -669, -467, -484, -651, -466, -1186, -743, -418, -440, -369, -767, -975, -721, -544, -835, -633, -480, -767, -866, -678, -655, -820, -515, -569, -382, -476, -922, -839, -351, -608, -882, -117, -230, -414, -423, -938, -829, -666, -817, -991, -362, -589, -556, -325, -752, -446, -475, -460, -756, -434, -821, -420, -1024, -621, -222, -529, -748, -372, -855, -929, -749, -763, -494, -828, -778, -493, -693, -607, -649, -624, -648, -551, -740, -456, -836, -557, -711, -709, -676, -827, -640, -533, -883, -641, -571, -653, -858, -573, -570, -558, -1040, -468, -765, -570, -630, -664, -657, -220, -499, -515, -983, -627, -682, -694, -915, -770, -383, -562, -488, -671, -773, -570, -673, -723, -718, -432, -694, -661, -557, -736, -605, -896, -539, -556, -944, -573, -884, -691, -786, -628, -671, -779, -376, -582, -720, -356, -445, -893, -298, -992, -671, -728, -747, -735, -1123, -525, -609, -202, -614, -795, -611, -880, -522, -916, -573, -242, -674, -561, -553, -790, -848, -354, -715, -646, -785, -729, -410, -712, -671, -646, -750, -707, -919, -696, -615, -717, -880, -555, -648, -1049, -454, -366, -670, -464, -582, -535, -698, -548, -718, -693, -680, -224, -487, -527, -517, -656, -343, -845, -629, -526, -532, -563, -880, -412, -793, -1054, -705, -592, -962, -752, -473, -925, -599, -560, -770, -414, -563, -822, -630, -454, -677, -582, -871, -644, -792, -551, -483, -528, -856, -755, -591, -544, -812, -836, -848, -804, -689, -449, -707, -744, -514, -756, -503, -870, -884, -623, -961, -668, -458, -752, -557, -945, -615, -891, -582, -900, -787, -891, -404, -389, -875, -683, -772, -749, -762, -663, -1127, -511, -924, -412, -1030, -848, -982, -512, -216, -586, -420, -637, -265, -633, -477, -728, -595, -622, -752, -979, -860, -539, -535, -855, -472, -672, -645, -641, -815, -262, -279, -428, -708, 3262, -299, -462, -472, 10152, -824, -625, -753, -3828, -475, 459, 1492, 258, -667, -753, -812, 420, -935, 168, 696, 5998, 7827, -780, -621, -4842, -810, -782, -490, 10417, 10471, -353, -827, 225, -597, -630, -656, 6001, -536, -655, -536, -350, -495, -808, -7116, 10597, -591, -374, -671, -535, -391, -812, -703, -791, -536, -746, -704, -564, -698, -261, -724, 1258, -300, -711, -223, -881, 10189, 10119, 4726, 3981, -833, -742, -821, -451, 1265, -1123, 10494, 6948, 2444, -951, -541, -706, -4791, 8860, 10612, 10487, 10280, -710, -914, -705, 226, 10488, 10602, 1591, 10374, -1011, -701, -688, -4947, 8411, 6405, 3724, 10647, -793, -780, -1202, 9953, -754, -542, 1696, 2672, -927, -746, -345, -2958, -393, 6947, 1989, -682, -1159, -793, -498, -2428, -240, 691, -575, -768, -577, -908, 766, -3349, -912, 6480, 5492, 7362, -708, -894, 2245, -1408, 5145, 3016, 10353, 10380, -633, -575, -2291, 7117, 6567, 9476, 6275, 10598, -423, -488, 1017, 7117, 6583, 1747, 4299, 10545, -219, -862, 3432, 6105, 9175, 4389, 9837, 9211, -842, -827, 3662, 5225, 3999, 7533, -1107, 10367, -917, -533, 6620, 4745, 6972, 9643, 677, 9715, -1181, -365, -2648, 3915, -484, -596, -315, -410, -499, -969, -707, 1459, 1794, 6719, 10633, 10456, -785, -554, -671, 2992, 9732, 3159, 10685, 10625, -665, -598, -775, -6051, 6616, 9865, 9807, 10579, -496, -722, -709, 6070, 8426, 10670, 10692, 10386, -824, -598, -631, 6876, 9862, 10692, 10579, 7130, -920, -818, -668, -2027, 7314, 10633, 10603, 10157, -538, -675, -631, 7237, 8839, 8902, 10242, 10544, -632, -608, -709, -3053, 7698, 6810, 6812, 8599, -690, -854, -791, 256, -172, 7824, 9605, 9676, -693, -598, -705, 814, 9107, 9892, 2865, 10583, -659, -546, -651, -5412, -193, 8287, 10685, 9534, -452, -551, -639, 6732, 10615, 10182, 9797, 10611, -716, -544, -553, 6392, 7462, 8655, 10328, 10537, -876, -624, -929, -5862, 6400, -649, 8650, 10655, -565, -821, -448, 5229, 5588, 960, 9928, 10625, -698, -841, -470, -633, -1279, 624, 2215, 7518, -762, -442, -440, -5710, 5681, 8151, 10543, 8857, -542, -395, -754, 565, 10447, 6818, 9625, 10215, -669, -439, -735, -1218, 9976, 10438, 10670, 10532, -135, -876, -779, 8222, 4520, 5266, 9661, 6805, -547, -462, -835, 7462, 9363, 8054, 10088, 10413, -408, -643, -616, -358, -5302, 4316, 6893, 4590, -638, -779, -396, 4521, 6231, 9250, 10606, 10431, -724, -649, -865, -3479, -1280, 7619, 9400, 10611, -536, -1151, -872, -331, -724, -615, -793, -1055, -443, -726, -916, -713, -847, -623, -863, -327, -848, -1094, -634, -757, -1039, -515, -1001, -615, -728, -615, -714, -619, -456, -723, -578, -571, -523, -730, -697, -636, -801, -680, -583, -689, -781, -349, -733, -758, -938, -815, -441, -607, -665, -741, -690, -407, -589, -678, -646, -719, -629, -817, -341, -711, -377, -358, -538, -540, -839, -699, -619, -361, -653, -341, -694, -852, -505, -692, -574, -735, -733, -867, -735, -612, -879, -423, -508, -408, -658, -901, -607, -687, -923, -608, -741, -781, -524, -880, -539, -759, -449, -155, -978, -296, -510, -696, -711, -466, -506, -581, -777, -680, -692, -827, -698, -686, -872, -727, -785, -554, -639, -776, 43, -735, -628, -681, -512, -382, -564, -534, -719, -281, -911, -723, -789, -711, -598, -870, -537, -888, -849, -254, -909, -913, -5187, 10686, 3016, 9184, -676, -897, -604, -733, -416, -5983, 4837, 8088, -703, -563, -677, -788, -3428, 2687, 7843, 9103, -535, -521, -505, -638, 1377, -385, 8432, 10619, -696, -461, -662, -551, -462, -3779, 1773, -310, -784, -874, -617, -502, 2474, -472, -531, -305, -337, -552, -436, -916, -575, -556, 7474, -712, -870, -236, -801, -5887, 2806, 10685, 9266, 9963, -945, -677, -982, 5271, -885, 5757, -288, 8738, -595, -1123, -419, -5538, 6075, 9970, 5174, 10692, -730, -608, -463, -10430, 513, -1422, 8046, 9665, -546, -477, -741, 5422, -6394, -5900, 8175, 10566, -694, -807, -459, -6713, 10445, 10319, 10685, 9484, -332, -682, -753, 2900, -588, 8250, 4376, -712, -945, -437, -710, -9574, 8176, 10676, 142, 5185, -279, -435, -632, 2232, 1578, 10435, 2353, 8700, -521, -559, -904, -389, -6132, 3773, -216, 10355, -952, -537, -439, -7473, 5891, 5947, 10078, 10484, -505, -693, -829, 1298, 9706, 3456, 8025, 10579, -734, -479, -623, -5956, 7153, 10572, 10232, 9721, -508, -710, -465, 4549, 5808, 4387, 2723, 10488, -853, -560, -849, 2180, -5266, 3582, 5152, 7860, -525, -380, -457, 9135, -600, 46, -81, -870, -1022, -666, -746, -9263, 4425, 7131, 680, 10655, -702, -798, -860, -4098, 8299, 3683, 10123, 10393, -604, -787, -388, -3188, 6463, 9274, 10294, 10522, -811, -564, -465, -8116, -5910, 4829, 9009, 10670, -387, -538, -820, -1700, 7015, 2030, 9845, 10445, -424, -698, -380, -1883, 2956, 5695, 6806, 2295, -776, -801, -382, 4788, 9422, 3157, 3350, 10540, -832, -735, -922, -2359, 2429, 3774, 4686, 9363, -571, -927, -982, 1924, 10085, 10309, 10619, 10579, -560, -785, -415, -711, 8914, 4454, 10457, 10580, -688, -849, -792, -3934, 10670, 5064, 10457, 9443, -610, -732, -819, 1701, 6789, -5514, 338, 10565, -779, -394, -415, 951, 10151, 861, 1344, 10444, -698, -657, -415, -4017, 10692, 10596, 9788, 10609, -741, -649, -548, -236, 4998, 8116, 3257, 10618, -703, -777, -532, -6345, -1742, -2751, 6957, 10685, -729, -676, -927, 1707, 394, 10091, 9451, 7050, -449, -471, -785, -3928, 6200, 2052, 4107, 10267, -689, -798, -600, 5466, 3192, 9656, 9857, 10404, -653, -850, -681, -5474, 9871, 10517, 6436, 9038, -745, -555, -923, 2436, 8684, 7034, 8313, 10640, -643, -354, -444, 8805, 10502, 10685, 8975, 10211, -446, -248, -765, 4099, 7582, 8938, 3979, 10640, -993, -487, -1022, -1191, 4211, 4861, 499, 7328, -701, -160, -651, -6764, 10543, 6663, 10178, 10685, -524, -883, -320, 440, 10677, 9250, 8020, 10600, -526, -896, -589, 2899, 10118, 5268, 6239, 10685, -538, -590, -991, 7412, 8056, 7870, 9259, 6341, -661, -531, -613, 2140, 6358, 7800, 10588, 2734, -301, -567, -208, 10446, 10301, 10635, 6734, 10595, -635, -505, -362, -3453, 10463, 10403, 10094, 5187, -537, -1211, -417, 10, 9916, 9398, 6166, 10241, -691, -690, -697, -656, 6487, 8840, 9518, 10595, -761, -640, -404, -836, 7184, 7810, 3255, 10626, -481, -1024, -822, -549, 1487, 1660, 4529, 5508, -735, -944, -554, -478, -814, -2480, 4193, 4894, -716, -760, -649, -743, 7399, 4274, 2991, 8658, -655, -856, -736, -758, 1969, -2819, 177, 10364, -366, -955, -316, -807, -887, 3528, 5053, 10655, -658, -699, -772, -347, -792, 3016, 3637, 10396, -978, -1036, -753, -928, -732, -579, 7194, 7479, -1009, -607, -542, -1086, -7061, 5407, 4729, 10034, -476, -339, -803, -345, -1041, 8950, 4811, 10057, -695, -810, -900, -509, -8129, 7310, 8035, 7188, -785, -480, -361, -592, 8595, 5153, 8005, 10678, -792, -509, -463, -517, -4796, -1465, 3262, 3800, -597, -636, -615, -619, -7074, -689, 2107, 1407, -726, -723, -732, -517, -431, 10631, 1666, -305, -539, -563, -867, -10332, -2007, 9617, 9468, 10483, -382, -650, -534, -6576, -715, 10237, 4530, 10484, -556, -612, -515, -2463, -1443, 3424, 9562, 10554, -427, -538, -594, -9504, -5186, 3539, 9501, 10521, -667, -365, -1006, 1638, -1316, 3445, -5874, 10630, -169, -793, -766, -3343, 10377, 8479, 10633, 10640, -360, -807, -327, 4564, -3609, 9543, -1006, 7584, -803, -813, -683, -5689, 132, 10655, 106, -561, -680, -654, -828, -10427, 9609, 3193, 4044, 10361, -970, -246, -587, -5450, -7620, 3386, 1846, 6638, -903, -617, -794, -3477, 6992, 10274, 9846, 9206, -208, -551, -812, -9492, -6306, -349, 6762, 10397, -881, -598, -790, 2510, -6167, 5981, 6264, 10643, -390, -820, -1033, 44, -4550, 8059, 9330, 10485, -810, -1003, -377, -2028, -3708, 2758, 214, 10560, -611, -548, -535, -5864, 623, 10625, 10597, 9632, -563, -549, -538, -7970, 5094, 1189, 9578, 4834, -596, -559, -394, 752, 3402, 4905, 9715, 10626, -565, -449, -491, 8047, 521, -6546, 7997, 10670, -498, -644, -630, 1934, -5791, 3763, 6213, 10496, -543, -912, -609, -133, -3198, 10293, 10215, 10316, -611, -450, -565, -4954, -1763, 9767, 4527, 10553, -598, -497, -665, 5217, 10140, 3120, 10427, 7845, -831, -297, -533, -6189, 10269, 7282, 9727, 10535, -293, -497, -679, -2261, 10292, 10389, 10398, 9987, -801, -455, -684, 5826, 4704, 3911, -2406, 10182, -653, -562, -511, 8763, 10591, 9286, 10305, 9336, -675, -581, -826, -5415, -4307, 4401, 7925, 10573, -560, -886, -958, 3493, 5946, 3766, 10388, 10568, -306, -564, -768, 6756, 10161, 6805, 10685, 9931, -624, -681, -778, -7376, 83, 2290, 9368, 10553, -294, -716, -1111, 5622, 5989, 4490, 7595, 4954, -803, -822, -706, -7023, 76, 5853, 10168, 10522, -527, -950, -958, 5574, 10600, 1261, -660, 10032, -860, -712, -644, 4017, 1907, 8386, 9179, 10425, -469, -713, -637, 10293, 9587, 4754, 8981, 10685, -413, -570, -750, 6084, 812, 10595, 9971, 10505, -190, -347, -595, 3281, 9979, 7432, 10201, 6389, -456, -321, -842, 5124, 10333, 4597, -276, 7219, -558, -388, -883, -6251, -5709, 10549, 4517, 10488, -584, -589, -720, -3377, 4545, -265, 5011, 9314, -569, -617, -480, 10510, 10670, 8170, 10438, 10670, -540, -576, -786, 3277, 10582, 7443, 8104, 1512, -313, -498, -662, 10625, 9087, 9919, 9628, 10661, -1027, -571, -816, 7251, 7019, 10119, 10692, 10595, -832, -794, -458, 361, 9594, 10515, 5007, 10601, -828, -705, -675, 10447, 10364, 10609, 7173, 10640, -803, -213, -623, -747, 10428, -468, -450, 7421, -681, -619, -700, -630, 5066, 10685, 5337, 9939, -602, -648, -634, -564, -2743, -1092, 2233, 7948, -839, -695, -497, -401, 8779, -2001, -1627, 7694, -414, -1024, -353, -676, -7552, 9674, -134, -543, -464, -934, -1059, -756, 4455, 5460, 769, 10605, -216, -556, -612, -855, -6367, 9527, 10605, 5316, -589, -652, -668, -658, -863, -401, -667, -632, -620, -743, -719, -418, 5582, 1401, 10513, 10622, -779, -493, -348, -591, -570, -69, 7204, 9660, -730, -847, -1074, -278, 1630, 625, 10106, 10186, -599, -614, -913, -751, 17, 3263, 4740, 5335, -577, -997, -920, -437, 2277, -480, 3551, 9345, -906, -410, -610, -1001, 2408, -7093, 3549, 10534, -1050, -578, -836, -653, -622, -4688, 5268, 2334, -189, -539, -649, -684, -608, -434, 8871, -869, -659, -560, -338, -984, -872, -795, 9434, -905, -560, -832, -653, -5613, -241, -4884, 6768, 5463, -665, -626, -529, -8091, 1985, 1617, 6547, 10566, -608, -391, -640, -51, -4329, 1940, 7668, 10197, -773, -343, -575, -5893, -9732, -3030, 6125, 10492, -455, -552, -855, -362, -6506, -7481, 4596, 10662, -965, -554, -405, -9192, 3815, -333, 9817, 2236, -388, -663, -408, 2188, -447, 1461, 1469, 10017, -392, -713, -436, -4549, -489, -643, -544, -590, -814, -1094, -912, -3088, -6977, 1843, 9082, 10107, -729, -613, -832, 5049, -6593, -6842, -595, 4477, -827, -421, -486, 4071, -8518, 2067, 7797, 6336, -879, -483, -812, -6621, -926, -2914, 10692, 9965, -758, -686, -647, -5408, -8725, -2604, 8126, 10607, -759, -532, -604, -6723, -3096, -762, 7614, 10183, -593, -453, -582, 18, -3232, -2218, 536, 10058, -504, -862, -497, 3712, 319, 3054, -794, 6465, -322, -431, -740, -3732, 2497, 5198, 5956, 6515, -819, -736, -579, 275, 6173, 4343, 10640, 10548, -859, -601, -630, 2826, 2037, -789, 7337, 9501, -453, -762, -735, 3248, -4964, -4105, 6795, 10614, -724, -666, -414, 227, 7471, 5625, 10610, 9935, -640, -502, -887, -1585, -2360, 2502, -2358, 6294, -720, -370, -1070, -5525, 3729, 7247, -2510, 10538, -886, -865, -550, -7242, -3631, 5412, 1563, 5919, -1183, -671, -771, -1064, 2154, 2938, 10445, 10045, -443, -662, -609, 2432, -2161, -3550, 9089, 10496, -373, -303, -683, -1561, -284, 7528, 10057, 10692, -815, -753, -700, -3470, 352, 6733, 8300, 10431, -637, -641, -656, 3624, -3385, -742, -3667, 7478, -817, -715, -906, -5844, 10592, 5373, 8956, 4895, -690, -425, -488, 3823, -212, -152, -596, 9843, -358, -663, -934, 9542, 6270, 3536, 6245, 10333, -941, -772, -1067, 1978, 13, 5150, 7917, 10629, -617, -852, -516, -1675, 4803, 9725, 907, 8794, -752, -858, -520, 6508, 5961, 10590, 8094, 7440, -697, -877, -833, 1300, 5697, 9660, 8795, 4359, -692, -618, -890, 10136, 7575, 9298, 6031, 10468, -404, -750, -684, 4055, 2618, 8721, -583, 9121, -526, -584, -363, -393, -1547, -374, -465, 3660, -403, -429, -444, 106, -583, 8538, 8229, 7687, -387, -925, -531, 2310, 1651, 10250, 10685, 10640, -927, -598, -746, -169, 5083, 3470, 7264, 3344, -433, -880, -491, -1123, 2071, 10044, 9853, 10535, -523, -496, -792, 9329, 7354, 7636, 10577, 10589, -692, -541, -546, -2651, 3344, 3833, 6551, 10109, -575, -756, -266, 8580, 4844, 10517, 10685, 10678, -612, -328, -395, -2126, 10608, 2360, 3081, 10558, -697, -670, -796, -312, 8383, 5543, 10558, 10365, -501, -434, -673, -577, 78, 9619, 10005, 10588, -910, -525, -759, -768, 7746, 2823, 3980, 10561, -713, -357, -722, -441, 5604, 5872, 10438, 10611, -732, -684, -851, -695, 2757, 2820, 10371, 10550, -716, -778, -975, -386, 7384, 10548, 10257, 7798, -747, -419, -379, -827, 980, 2590, 10143, 8240, -831, -598, -437, -308, 4799, 10655, 10580, 10347, -546, -1237, -797, -672, -3419, 8825, 1143, 9045, -765, -955, -415, -582, -357, 2906, 9659, 2952, -642, -718, -736, -792, 3694, 2819, 10483, 7760, -594, -678, -666, -731, 128, 10537, 7119, 2869, -454, -385, -861, -445, -208, -4397, 9541, 7455, -747, -438, -695, -542, 1237, -363, 6305, 3715, -1045, -422, -434, -892, 793, -4163, 9671, 6409, -559, -794, -588, -332, 8588, -459, 10552, 5406, -986, -469, -699, -424, -683, -401, 8934, -509, -441, -703, -564, -1015, 4153, -624, 10615, 4637, -848, -848, -852, 5441, 2261, 8434, 7557, 9816, -356, -658, -734, 923, 3832, 10043, 10086, 10315, -777, -662, -869, -10354, -2516, 6257, 1893, 1156, -402, -440, -394, -5650, -908, -3827, 3502, 2091, -947, -667, -900, 8183, 7164, 9097, 9554, 1356, -856, -688, -976, 5513, -49, 10640, 3175, -8920, -448, -849, -353, -4057, 8822, -726, 8731, -752, -558, -482, -722, 2719, 8905, 10141, 4952, 9139, -619, -571, -643, -4901, 8572, -3350, 1408, 2866, -697, -747, -812, -809, 10290, 9057, 9238, 9660, -535, -671, -464, 2985, 7724, 3784, 8456, 6669, -767, -699, -728, 3698, 809, 6517, 3628, 1553, -539, -600, -629, -2183, -10164, 10545, -149, 6488, -587, -474, -876, 7296, 2056, 4824, -6291, 8123, -362, -693, -748, 3289, 4781, 9736, -768, 6107, -625, -903, -618, 3327, 10657, 10508, 8551, 10517, -392, -1079, -513, 2160, 2089, 10561, 10468, 10517, -855, -600, -601, 3635, 6567, 10496, 5004, 9865, -864, -785, -610, 3823, 5650, 9803, 8892, 7860, -424, -640, -588, 9887, 10452, 8555, 10670, 6897, -831, -810, -934, 7885, 3866, 9799, 2649, 6798, -782, -858, -932, 3041, 9079, 8959, 5176, -581, -468, -768, -627, 9203, 10624, 9084, 9161, 10606, -606, -785, -630, -2128, 2243, 10303, 9309, 7529, -602, -374, -582, -1440, 10056, 7364, 9781, 8805, -690, -584, -804, -7899, 7375, 6719, 10566, 10685, -687, -714, -629, 1152, 9149, 10506, 20, 7619, -674, -718, -785, 3268, 10461, 10481, 8231, 2344, -835, -258, -291, -2467, 9229, 10670, 9486, 10159, -552, -421, -544, 7977, 10692, 5245, 5751, 7197, -417, -407, -316, 7561, 6502, -6384, 689, 10543, -513, -794, -132, -4975, 7129, 6168, 8158, 9376, -611, -696, -877, 6818, 9593, 9979, 8418, 3335, -839, -1026, -1097, -378, 7055, 2996, 6750, 9621, -589, -916, -647, 1552, 8253, 5387, 9657, 10583, -787, -637, -424, 6744, 9644, 10138, 10184, 10246, -872, -492, -525, -1557, 10477, 9763, 8603, 10655, -829, -761, -644, -1813, 2233, 9743, 27, 9850, -692, -633, -1014, 9497, 3480, 9191, -878, 3666, -498, -862, -373, 911, 7791, 8291, 10655, 10578, -823, -545, -500, 6957, 10647, 10647, 9761, 10670, -308, -873, -355, 9105, 10692, 8998, 9804, 10349, -462, -349, -615, 5871, 4131, 10580, 10323, 10577, -335, -1009, -578, 5956, 10099, 5263, 9595, 10484, -493, -275, -886, 10431, 3936, 828, 10230, 10566, -544, -564, -479, 5533, 10655, 10337, 10678, 10655, -634, -287, -570, -275, 1367, 10491, 1133, 10622, -409, -795, -172, -583, 10143, 10678, 9286, 10500, -320, -268, -350, -540, 4449, 5407, 9516, 10523, -780, -661, -814, -660, 7920, 7112, 10077, 10430, -496, -340, -774, -769, 7141, -129, 9468, 10634, -845, -700, -884, -856, 402, 6308, 10105, 10685, -502, -624, -746, -790, -5829, 5832, 10381, 10514, -724, -418, -316, -354, -2472, 6645, 6261, 10423, -848, -570, -839, -723, 10511, 9405, 10265, 10565, -616, -594, -764, -511, -402, -827, -591, -538, -504, -548, -1117, -737, -566, -808, -667, -685, -614, -661, -494, -779, -839, -695, -823, -671, -579, -631, -731, -892, -467, -540, -627, -756, -497, -594, -266, -690, -580, -473, -517, -592, -475, -663, -781, -568, -760, -1139, -492, -535, -552, -644, -976, -656, -884, -667, -739, -724, -566, -398, -643, -493, -510, -796, -610, -876, -824, -765, -348, -566, -621, -593, -612, -753, -478, -760, -758, -811, -710, -961, -832, -765, -765, -652, -570, -422, -775, -565, -560, -789, -885, -922, -394, -684, -753, -691, -599, -816, -744, -567, -480, -685, -997, -574, -680, -615, -528, -427, -413, -725, -596, -657, -876, -561, -366, -582, -581, -735, -636, -492, -689, -638, -727, -807, -699, -744, -686, -444, -729, -581, -501, -600, -632, -973, -954, -393, -380, -479, -689, -794, -409, -755, -806, -458, -542, -652, -704, -354, -865, -622, -469, -534, -738, -647, -921, -676, -757, -518, -755, -695, -600, -619, -547, -529, -679, -537, -486, -974, -847, -542, -746, -592, -465, 22, -608, -1217, -379, -273, -735, -279, -316, -533, -656, -703, -476, -776, -820, -442, -561, -763, -674, -768, -888, -959, -323, -506, -777, -496, -695, -632, -346, -441, -430, -724, -593, -1174, 1979, -707, -790, -733, -692, -755, -662, 354, -410, 2915, -671, -575, -309, -412, -450, -1853, -607, -365, -664, -481, -523, -514, -594, -7416, 516, -963, -638, -612, -560, -136, -543, -1621, -679, 6358, -228, -199, -739, -795, -764, -295, -696, -820, -472, -840, -569, -574, -683, 1586, -348, 231, -680, -731, -500, -782, -1012, -477, -718, -331, -991, -704, -620, -579, -340, 4970, 8274, 2052, 821, -362, -637, -617, -835, 305, 568, 2873, -297, -406, -544, -844, -409, -528, 9912, 10366, -528, 6486, -834, -923, -704, -4583, 5497, 6780, 10457, 8754, -667, -204, -822, 6, -326, 787, -660, 4625, -686, -644, -418, 2368, -380, 6838, -762, -303, -600, -477, -839, -405, 245, 3365, -570, 10218, -939, -576, -788, -615, -369, 7515, -403, -657, -377, -596, -754, -680, 6030, 820, -487, -12, -267, -317, -464, 3051, 10685, 5836, 6951, 8289, -658, -796, -649, 6072, 9296, 10594, 9012, 10634, -513, -873, -692, 4638, 7882, 8334, 9854, 10631, -862, -346, -608, -84, -895, 2725, 3604, 10692, -490, -312, -670, -728, 7455, 9578, -180, 10692, -513, -387, -746, 5126, 1061, 10459, -421, 10508, -945, -449, -705, -661, 1, 3611, 269, 9304, -475, -666, -675, 10398, 9498, 10553, 9790, 10640, -733, -835, -759, 6525, 10526, 10580, 10491, 10611, -638, -485, -383, 10595, 2592, 9796, 10459, 10327, -661, -678, -520, -4900, 4931, 2465, 10499, 10660, -850, -825, -431, 10490, 5680, 10580, 9773, 10401, -719, -785, -495, -7495, 8608, 10475, 10640, 10648, -451, -487, -557, 8812, 7908, 10692, 10494, 10618, -1058, -322, -795, -647, -759, 687, -706, -304, -530, -737, -686, -655, -380, -775, 3040, 6151, -510, -253, -543, -844, -1842, 3525, 5826, 6074, -510, -460, -926, -647, 6500, 4509, 10591, 10692, -1035, -876, -820, -545, 10504, 8962, 8901, 10678, -612, -840, -697, -612, -76, 8032, 10685, 10692, -350, -488, -809, -950, 7450, 3965, 8117, 10629, -867, -568, -775, -912, 5987, 170, 10596, 10572, -786, -649, -564, -711, -639, -1012, -631, -227, -669, -251, -745, -453, -613, -817, -456, -527, -748, -338, -877, -605, -457, -415, -850, -528, -188, -763, -558, -719, -597, -706, -1154, -453, -830, -526, -678, -822, -731, -795, -658, -868, -578, -511, -587, -441, -505, -605, -952, -447, -754, -332, -475, -496, -909, -1060, -783, -762, -732, -1073, -467, -896, -634, -655, -713, -606, -497, -536, -591, -1139, -698, -937, -688, -1014, -486, -611, -601, -673, -598, -551, -917, -512, -789, -335, -673, -549, -748, -892, -890, -424, -706, -666, -484, -588, -880, -576, -842, -575, -601, -655, -460, -392, -844, -833, -782, -706, -882, -625, -815, -482, -904, -428, -1041, -588, -798, -955, -795, -709, -639, -913, -712, -638, -239, -775, -463, -632, -437, -760, -740, -436, -807, -815, -743, -804, -768, -618, -908, -835, -769, -690, -647, -932, -800, -508, -601, -712, -656, -611, -563, -587, -684, -541, -477, -610, -565, -485, -640, -397, -800, -478, -181, -660, -732, -658, -686, -852, -755, -875, -618, -626, -605, -349, -498, -391, -658, -1104, -911, -582, -779, -744, -971, -517, -707, -699, -880, -543, -880, -675, -743, -621, -830, -520, -309, -431, -662, -585, -800, -605, -630, -763, -744, -808, -675, -537, -793, -323, -654, -979, -304, -366, -755, -453, -893, -447, -468, -587, -647, -551, -566, -670, -395, -652, -373, -709, -491, -444, -830, -813, -562, -764, -838, -614, -644, -294, -782, -667, -863, -671, -854, -683, -499, -687, -618, -663, -551, -985, -777, -798, -387, -929, -849, -891, -455, -903, -644, -430, -1094, -734, -856, -743, -723, -808, -519, -537, -719, -472, -755, -1012, -509, -832, -857, -795, -866, -380, -455, -719, -822, -1046, -494, -540, -762, -449, -635, -658, -768, -579, -1087, -355, -502, -646, -642, -696, -508, -878, -660, -363, -546, -584, -451, -825, -822, -331, -794, -502, -650, -500, -879, -979, -267, -189, -534, -505, -962, -661, -893, -620, -127, -373, -549, -604, -713, -693, -818, -469, -642, -854, -369, -734, -705, -504, -540, -404, -595, -569, -454, -826, -574, -734, -451, -508, -880, -697, -902, -523, -637, -912, -444, -1228, -852, -657, -657, -496, -626, -779, -515, -765, -822, -723, -440, -768, -794, -499, -366, -826, -578, -717, -542, -850, -626, -449, -738, -552, -401, -811, -691, -499, -713, -741, -283, -770, -595, -941, -988, -621, -708, -612, -745, -555, -751, -822, -753, -646, -398, -974, -829, -628, -628, -936, -582, -519, -1090, -601, -471, -804, -769, -357, -611, -875, -721, -688, -811, -1067, -768, -721, -780, -708, -605, -1077, -344, -991, -1148, -611, -697, -878, -600, -669, -803, -757, -572, -679, -665, -380, -537, -707, -552, -467, -854, -500, -594, -1174, -577, -664, -790, -943, -658, -759, -840, -482, -347, -438, -461, -865, -545, -715, -722, -747, -883, -639, -408, -319, -438, -512, -647, -790, -727, -733, -557, -502, -745, -730, -512, -595, -940, -305, -486, -627, -434, -1229, -793, -673, -429, -642, -1039, -862, -506, -888, -661, -551, -564, -477, -628, -992, -288, -519, -475, -883, -831, -499, -547, -435, -444, -309, -694, -468, -673, -615, -865, -553, -522, -1034, -687, -816, -758, -625, -625, -539,
};

TUNE(SetRange(-10692, 10692), savedCaptureHistory);

namespace TB = Tablebases;

void syzygy_extend_pv(const OptionsMap&            options,
                      const Search::LimitsType&    limits,
                      Stockfish::Position&         pos,
                      Stockfish::Search::RootMove& rootMove,
                      Value&                       v);

using namespace Search;

namespace {

// (*Scalers):
// The values with Scaler asterisks have proven non-linear scaling.
// They are optimized to time controls of 180 + 1.8 and longer,
// so changing them or adding conditions that are similar requires
// tests at these types of time controls.

// Futility margin
Value futility_margin(Depth d, bool noTtCutNode, bool improving, bool oppWorsening) {
    Value futilityMult       = 112 - 26 * noTtCutNode;
    Value improvingDeduction = improving * futilityMult * 2;
    Value worseningDeduction = oppWorsening * futilityMult / 3;

    return futilityMult * d - improvingDeduction - worseningDeduction;
}

constexpr int futility_move_count(bool improving, Depth depth) {
    return (3 + depth * depth) / (2 - improving);
}

int correction_value(const Worker& w, const Position& pos, const Stack* const ss) {
    const Color us    = pos.side_to_move();
    const auto  m     = (ss - 1)->currentMove;
    const auto  pcv   = w.pawnCorrectionHistory[pawn_structure_index<Correction>(pos)][us];
    const auto  micv  = w.minorPieceCorrectionHistory[minor_piece_index(pos)][us];
    const auto  wnpcv = w.nonPawnCorrectionHistory[WHITE][non_pawn_index<WHITE>(pos)][us];
    const auto  bnpcv = w.nonPawnCorrectionHistory[BLACK][non_pawn_index<BLACK>(pos)][us];
    const auto  cntcv =
      m.is_ok() ? (*(ss - 2)->continuationCorrectionHistory)[pos.piece_on(m.to_sq())][m.to_sq()]
                 : 0;

    return 6995 * pcv + 6593 * micv + 7753 * (wnpcv + bnpcv) + 6049 * cntcv;
}

int risk_tolerance(const Position& pos, Value v) {
    // Returns (some constant of) second derivative of sigmoid.
    static constexpr auto sigmoid_d2 = [](int x, int y) {
        return -345600 * x / (x * x + 3 * y * y);
    };

    int material = pos.count<PAWN>() + 3 * pos.count<KNIGHT>() + 3 * pos.count<BISHOP>()
                 + 5 * pos.count<ROOK>() + 9 * pos.count<QUEEN>();

    int m = std::clamp(material, 17, 78);

    // a and b are the crude approximation of the wdl model.
    // The win rate is: 1/(1+exp((a-v)/b))
    // The loss rate is 1/(1+exp((v+a)/b))
    int a = ((-m * 3220 / 256 + 2361) * m / 256 - 586) * m / 256 + 421;
    int b = ((m * 7761 / 256 - 2674) * m / 256 + 314) * m / 256 + 51;


    // The risk utility is therefore d/dv^2 (1/(1+exp(-(v-a)/b)) -1/(1+exp(-(-v-a)/b)))
    // -115200x/(x^2+3) = -345600(ab) / (a^2+3b^2) (multiplied by some constant) (second degree pade approximant)
    int winning_risk = sigmoid_d2(v - a, b);
    int losing_risk  = -sigmoid_d2(-v - a, b);

    return (winning_risk + losing_risk) * 60 / b;
}

// Add correctionHistory value to raw staticEval and guarantee evaluation
// does not hit the tablebase range.
Value to_corrected_static_eval(const Value v, const int cv) {
    return std::clamp(v + cv / 131072, VALUE_TB_LOSS_IN_MAX_PLY + 1, VALUE_TB_WIN_IN_MAX_PLY - 1);
}

void update_correction_history(const Position& pos,
                               Stack* const    ss,
                               Search::Worker& workerThread,
                               const int       bonus) {
    const Move  m  = (ss - 1)->currentMove;
    const Color us = pos.side_to_move();

    static constexpr int nonPawnWeight = 165;

    workerThread.pawnCorrectionHistory[pawn_structure_index<Correction>(pos)][us]
      << bonus * 109 / 128;
    workerThread.minorPieceCorrectionHistory[minor_piece_index(pos)][us] << bonus * 141 / 128;
    workerThread.nonPawnCorrectionHistory[WHITE][non_pawn_index<WHITE>(pos)][us]
      << bonus * nonPawnWeight / 128;
    workerThread.nonPawnCorrectionHistory[BLACK][non_pawn_index<BLACK>(pos)][us]
      << bonus * nonPawnWeight / 128;

    if (m.is_ok())
        (*(ss - 2)->continuationCorrectionHistory)[pos.piece_on(m.to_sq())][m.to_sq()]
          << bonus * 138 / 128;
}

// Add a small random component to draw evaluations to avoid 3-fold blindness
Value value_draw(size_t nodes) { return VALUE_DRAW - 1 + Value(nodes & 0x2); }
Value value_to_tt(Value v, int ply);
Value value_from_tt(Value v, int ply, int r50c);
void  update_pv(Move* pv, Move move, const Move* childPv);
void  update_continuation_histories(Stack* ss, Piece pc, Square to, int bonus);
void  update_quiet_histories(
   const Position& pos, Stack* ss, Search::Worker& workerThread, Move move, int bonus);
void update_all_stats(const Position&      pos,
                      Stack*               ss,
                      Search::Worker&      workerThread,
                      Move                 bestMove,
                      Square               prevSq,
                      ValueList<Move, 32>& quietsSearched,
                      ValueList<Move, 32>& capturesSearched,
                      Depth                depth,
                      bool                 isTTMove,
                      int                  moveCount);

}  // namespace

Search::Worker::Worker(SharedState&                    sharedState,
                       std::unique_ptr<ISearchManager> sm,
                       size_t                          threadId,
                       NumaReplicatedAccessToken       token) :
    // Unpack the SharedState struct into member variables
    threadIdx(threadId),
    numaAccessToken(token),
    manager(std::move(sm)),
    options(sharedState.options),
    threads(sharedState.threads),
    tt(sharedState.tt),
    networks(sharedState.networks),
    refreshTable(networks[token]) {
    clear();
}

void Search::Worker::ensure_network_replicated() {
    // Access once to force lazy initialization.
    // We do this because we want to avoid initialization during search.
    (void) (networks[numaAccessToken]);
}

void Search::Worker::start_searching() {

    // Non-main threads go directly to iterative_deepening()
    if (!is_mainthread())
    {
        iterative_deepening();
        return;
    }

    main_manager()->tm.init(limits, rootPos.side_to_move(), rootPos.game_ply(), options,
                            main_manager()->originalTimeAdjust);
    tt.new_search();

    if (rootMoves.empty())
    {
        rootMoves.emplace_back(Move::none());
        main_manager()->updates.onUpdateNoMoves(
          {0, {rootPos.checkers() ? -VALUE_MATE : VALUE_DRAW, rootPos}});
    }
    else
    {
        threads.start_searching();  // start non-main threads
        iterative_deepening();      // main thread start searching
    }

    // When we reach the maximum depth, we can arrive here without a raise of
    // threads.stop. However, if we are pondering or in an infinite search,
    // the UCI protocol states that we shouldn't print the best move before the
    // GUI sends a "stop" or "ponderhit" command. We therefore simply wait here
    // until the GUI sends one of those commands.
    while (!threads.stop && (main_manager()->ponder || limits.infinite))
    {}  // Busy wait for a stop or a ponder reset

    // Stop the threads if not already stopped (also raise the stop if
    // "ponderhit" just reset threads.ponder)
    threads.stop = true;

    // Wait until all threads have finished
    threads.wait_for_search_finished();

    // When playing in 'nodes as time' mode, subtract the searched nodes from
    // the available ones before exiting.
    if (limits.npmsec)
        main_manager()->tm.advance_nodes_time(threads.nodes_searched()
                                              - limits.inc[rootPos.side_to_move()]);

    Worker* bestThread = this;
    Skill   skill =
      Skill(options["Skill Level"], options["UCI_LimitStrength"] ? int(options["UCI_Elo"]) : 0);

    if (int(options["MultiPV"]) == 1 && !limits.depth && !limits.mate && !skill.enabled()
        && rootMoves[0].pv[0] != Move::none())
        bestThread = threads.get_best_thread()->worker.get();

    main_manager()->bestPreviousScore        = bestThread->rootMoves[0].score;
    main_manager()->bestPreviousAverageScore = bestThread->rootMoves[0].averageScore;

    // Send again PV info if we have a new best thread
    if (bestThread != this)
        main_manager()->pv(*bestThread, threads, tt, bestThread->completedDepth);

    std::string ponder;

    if (bestThread->rootMoves[0].pv.size() > 1
        || bestThread->rootMoves[0].extract_ponder_from_tt(tt, rootPos))
        ponder = UCIEngine::move(bestThread->rootMoves[0].pv[1], rootPos.is_chess960());

    auto bestmove = UCIEngine::move(bestThread->rootMoves[0].pv[0], rootPos.is_chess960());
    main_manager()->updates.onBestmove(bestmove, ponder);
}

// Main iterative deepening loop. It calls search()
// repeatedly with increasing depth until the allocated thinking time has been
// consumed, the user stops the search, or the maximum search depth is reached.
void Search::Worker::iterative_deepening() {

    SearchManager* mainThread = (is_mainthread() ? main_manager() : nullptr);

    Move pv[MAX_PLY + 1];

    Depth lastBestMoveDepth = 0;
    Value lastBestScore     = -VALUE_INFINITE;
    auto  lastBestPV        = std::vector{Move::none()};

    Value  alpha, beta;
    Value  bestValue     = -VALUE_INFINITE;
    Color  us            = rootPos.side_to_move();
    double timeReduction = 1, totBestMoveChanges = 0;
    int    delta, iterIdx                        = 0;

    // Allocate stack with extra size to allow access from (ss - 7) to (ss + 2):
    // (ss - 7) is needed for update_continuation_histories(ss - 1) which accesses (ss - 6),
    // (ss + 2) is needed for initialization of cutOffCnt.
    Stack  stack[MAX_PLY + 10] = {};
    Stack* ss                  = stack + 7;

    for (int i = 7; i > 0; --i)
    {
        (ss - i)->continuationHistory =
          &this->continuationHistory[0][0][NO_PIECE][0];  // Use as a sentinel
        (ss - i)->continuationCorrectionHistory = &this->continuationCorrectionHistory[NO_PIECE][0];
        (ss - i)->staticEval                    = VALUE_NONE;
        (ss - i)->reduction                     = 0;
    }

    for (int i = 0; i <= MAX_PLY + 2; ++i)
    {
        (ss + i)->ply       = i;
        (ss + i)->reduction = 0;
    }

    ss->pv = pv;

    if (mainThread)
    {
        if (mainThread->bestPreviousScore == VALUE_INFINITE)
            mainThread->iterValue.fill(VALUE_ZERO);
        else
            mainThread->iterValue.fill(mainThread->bestPreviousScore);
    }

    size_t multiPV = size_t(options["MultiPV"]);
    Skill skill(options["Skill Level"], options["UCI_LimitStrength"] ? int(options["UCI_Elo"]) : 0);

    // When playing with strength handicap enable MultiPV search that we will
    // use behind-the-scenes to retrieve a set of possible moves.
    if (skill.enabled())
        multiPV = std::max(multiPV, size_t(4));

    multiPV = std::min(multiPV, rootMoves.size());

    int searchAgainCounter = 0;

    lowPlyHistory.fill(95);

    // Iterative deepening loop until requested to stop or the target depth is reached
    while (++rootDepth < MAX_PLY && !threads.stop
           && !(limits.depth && mainThread && rootDepth > limits.depth))
    {
        // Age out PV variability metric
        if (mainThread)
            totBestMoveChanges /= 2;

        // Save the last iteration's scores before the first PV line is searched and
        // all the move scores except the (new) PV are set to -VALUE_INFINITE.
        for (RootMove& rm : rootMoves)
            rm.previousScore = rm.score;

        size_t pvFirst = 0;
        pvLast         = 0;

        if (!threads.increaseDepth)
            searchAgainCounter++;

        // MultiPV loop. We perform a full root search for each PV line
        for (pvIdx = 0; pvIdx < multiPV; ++pvIdx)
        {
            if (pvIdx == pvLast)
            {
                pvFirst = pvLast;
                for (pvLast++; pvLast < rootMoves.size(); pvLast++)
                    if (rootMoves[pvLast].tbRank != rootMoves[pvFirst].tbRank)
                        break;
            }

            // Reset UCI info selDepth for each depth and each PV line
            selDepth = 0;

            // Reset aspiration window starting size
            delta     = 5 + std::abs(rootMoves[pvIdx].meanSquaredScore) / 13000;
            Value avg = rootMoves[pvIdx].averageScore;
            alpha     = std::max(avg - delta, -VALUE_INFINITE);
            beta      = std::min(avg + delta, VALUE_INFINITE);

            // Adjust optimism based on root move's averageScore
            optimism[us]  = 138 * avg / (std::abs(avg) + 81);
            optimism[~us] = -optimism[us];

            // Start with a small aspiration window and, in the case of a fail
            // high/low, re-search with a bigger window until we don't fail
            // high/low anymore.
            int failedHighCnt = 0;
            while (true)
            {
                // Adjust the effective depth searched, but ensure at least one
                // effective increment for every four searchAgain steps (see issue #2717).
                Depth adjustedDepth =
                  std::max(1, rootDepth - failedHighCnt - 3 * (searchAgainCounter + 1) / 4);
                rootDelta = beta - alpha;
                bestValue = search<Root>(rootPos, ss, alpha, beta, adjustedDepth, false);

                // Bring the best move to the front. It is critical that sorting
                // is done with a stable algorithm because all the values but the
                // first and eventually the new best one is set to -VALUE_INFINITE
                // and we want to keep the same order for all the moves except the
                // new PV that goes to the front. Note that in the case of MultiPV
                // search the already searched PV lines are preserved.
                std::stable_sort(rootMoves.begin() + pvIdx, rootMoves.begin() + pvLast);

                // If search has been stopped, we break immediately. Sorting is
                // safe because RootMoves is still valid, although it refers to
                // the previous iteration.
                if (threads.stop)
                    break;

                // When failing high/low give some update before a re-search. To avoid
                // excessive output that could hang GUIs like Fritz 19, only start
                // at nodes > 10M (rather than depth N, which can be reached quickly)
                if (mainThread && multiPV == 1 && (bestValue <= alpha || bestValue >= beta)
                    && nodes > 10000000)
                    main_manager()->pv(*this, threads, tt, rootDepth);

                // In case of failing low/high increase aspiration window and re-search,
                // otherwise exit the loop.
                if (bestValue <= alpha)
                {
                    beta  = (alpha + beta) / 2;
                    alpha = std::max(bestValue - delta, -VALUE_INFINITE);

                    failedHighCnt = 0;
                    if (mainThread)
                        mainThread->stopOnPonderhit = false;
                }
                else if (bestValue >= beta)
                {
                    beta = std::min(bestValue + delta, VALUE_INFINITE);
                    ++failedHighCnt;
                }
                else
                    break;

                delta += delta / 3;

                assert(alpha >= -VALUE_INFINITE && beta <= VALUE_INFINITE);
            }

            // Sort the PV lines searched so far and update the GUI
            std::stable_sort(rootMoves.begin() + pvFirst, rootMoves.begin() + pvIdx + 1);

            if (mainThread
                && (threads.stop || pvIdx + 1 == multiPV || nodes > 10000000)
                // A thread that aborted search can have mated-in/TB-loss PV and
                // score that cannot be trusted, i.e. it can be delayed or refuted
                // if we would have had time to fully search other root-moves. Thus
                // we suppress this output and below pick a proven score/PV for this
                // thread (from the previous iteration).
                && !(threads.abortedSearch && is_loss(rootMoves[0].uciScore)))
                main_manager()->pv(*this, threads, tt, rootDepth);

            if (threads.stop)
                break;
        }

        if (!threads.stop)
            completedDepth = rootDepth;

        // We make sure not to pick an unproven mated-in score,
        // in case this thread prematurely stopped search (aborted-search).
        if (threads.abortedSearch && rootMoves[0].score != -VALUE_INFINITE
            && is_loss(rootMoves[0].score))
        {
            // Bring the last best move to the front for best thread selection.
            Utility::move_to_front(rootMoves, [&lastBestPV = std::as_const(lastBestPV)](
                                                const auto& rm) { return rm == lastBestPV[0]; });
            rootMoves[0].pv    = lastBestPV;
            rootMoves[0].score = rootMoves[0].uciScore = lastBestScore;
        }
        else if (rootMoves[0].pv[0] != lastBestPV[0])
        {
            lastBestPV        = rootMoves[0].pv;
            lastBestScore     = rootMoves[0].score;
            lastBestMoveDepth = rootDepth;
        }

        if (!mainThread)
            continue;

        // Have we found a "mate in x"?
        if (limits.mate && rootMoves[0].score == rootMoves[0].uciScore
            && ((rootMoves[0].score >= VALUE_MATE_IN_MAX_PLY
                 && VALUE_MATE - rootMoves[0].score <= 2 * limits.mate)
                || (rootMoves[0].score != -VALUE_INFINITE
                    && rootMoves[0].score <= VALUE_MATED_IN_MAX_PLY
                    && VALUE_MATE + rootMoves[0].score <= 2 * limits.mate)))
            threads.stop = true;

        // If the skill level is enabled and time is up, pick a sub-optimal best move
        if (skill.enabled() && skill.time_to_pick(rootDepth))
            skill.pick_best(rootMoves, multiPV);

        // Use part of the gained time from a previous stable move for the current move
        for (auto&& th : threads)
        {
            totBestMoveChanges += th->worker->bestMoveChanges;
            th->worker->bestMoveChanges = 0;
        }

        // Do we have time for the next iteration? Can we stop searching now?
        if (limits.use_time_management() && !threads.stop && !mainThread->stopOnPonderhit)
        {
            int nodesEffort = rootMoves[0].effort * 100000 / std::max(size_t(1), size_t(nodes));

            double fallingEval =
              (11.396 + 2.035 * (mainThread->bestPreviousAverageScore - bestValue)
               + 0.968 * (mainThread->iterValue[iterIdx] - bestValue))
              / 100.0;
            fallingEval = std::clamp(fallingEval, 0.5786, 1.6752);

            // If the bestMove is stable over several iterations, reduce time accordingly
            timeReduction = lastBestMoveDepth + 8 < completedDepth ? 1.4857 : 0.7046;
            double reduction =
              (1.4540 + mainThread->previousTimeReduction) / (2.1593 * timeReduction);
            double bestMoveInstability = 0.9929 + 1.8519 * totBestMoveChanges / threads.size();

            double totalTime =
              mainThread->tm.optimum() * fallingEval * reduction * bestMoveInstability;

            // Cap used time in case of a single legal move for a better viewer experience
            if (rootMoves.size() == 1)
                totalTime = std::min(500.0, totalTime);

            auto elapsedTime = elapsed();

            if (completedDepth >= 10 && nodesEffort >= 97056 && elapsedTime > totalTime * 0.6540
                && !mainThread->ponder)
                threads.stop = true;

            // Stop the search if we have exceeded the totalTime or maximum
            if (elapsedTime > std::min(totalTime, double(mainThread->tm.maximum())))
            {
                // If we are allowed to ponder do not stop the search now but
                // keep pondering until the GUI sends "ponderhit" or "stop".
                if (mainThread->ponder)
                    mainThread->stopOnPonderhit = true;
                else
                    threads.stop = true;
            }
            else
                threads.increaseDepth = mainThread->ponder || elapsedTime <= totalTime * 0.5138;
        }

        mainThread->iterValue[iterIdx] = bestValue;
        iterIdx                        = (iterIdx + 1) & 3;
    }

    if (!mainThread)
        return;

    // int16_t arr[16*64*8] = {};
    // int16_t* arr_ptr = arr;

    // captureHistory.save(arr_ptr);

    // for (int i = 0; i < 16*64*8; i++){
    //     std::cout << (int)arr[i] << ", ";
    // }

    mainThread->previousTimeReduction = timeReduction;

    // If the skill level is enabled, swap the best PV line with the sub-optimal one
    if (skill.enabled())
        std::swap(rootMoves[0],
                  *std::find(rootMoves.begin(), rootMoves.end(),
                             skill.best ? skill.best : skill.pick_best(rootMoves, multiPV)));
}

// Reset histories, usually before a new game
void Search::Worker::clear() {
    mainHistory.fill(65);
    lowPlyHistory.fill(107);

    int* savedCaptureHistoryPtr = savedCaptureHistory;
    captureHistory.load(savedCaptureHistoryPtr);

    pawnHistory.fill(-1215);
    pawnCorrectionHistory.fill(4);
    minorPieceCorrectionHistory.fill(0);
    nonPawnCorrectionHistory[WHITE].fill(0);
    nonPawnCorrectionHistory[BLACK].fill(0);

    for (auto& to : continuationCorrectionHistory)
        for (auto& h : to)
            h.fill(0);

    for (bool inCheck : {false, true})
        for (StatsType c : {NoCaptures, Captures})
            for (auto& to : continuationHistory[inCheck][c])
                for (auto& h : to)
                    h.fill(-493);

    for (size_t i = 1; i < reductions.size(); ++i)
        reductions[i] = int(2937 / 128.0 * std::log(i));

    refreshTable.clear(networks[numaAccessToken]);
}


// Main search function for both PV and non-PV nodes
template<NodeType nodeType>
Value Search::Worker::search(
  Position& pos, Stack* ss, Value alpha, Value beta, Depth depth, bool cutNode) {

    constexpr bool PvNode   = nodeType != NonPV;
    constexpr bool rootNode = nodeType == Root;
    const bool     allNode  = !(PvNode || cutNode);

    // Dive into quiescence search when the depth reaches zero
    if (depth <= 0)
    {
        constexpr auto nt = PvNode ? PV : NonPV;
        return qsearch<nt>(pos, ss, alpha, beta);
    }

    // Limit the depth if extensions made it too large
    depth = std::min(depth, MAX_PLY - 1);

    // Check if we have an upcoming move that draws by repetition
    if (!rootNode && alpha < VALUE_DRAW && pos.upcoming_repetition(ss->ply))
    {
        alpha = value_draw(this->nodes);
        if (alpha >= beta)
            return alpha;
    }

    assert(-VALUE_INFINITE <= alpha && alpha < beta && beta <= VALUE_INFINITE);
    assert(PvNode || (alpha == beta - 1));
    assert(0 < depth && depth < MAX_PLY);
    assert(!(PvNode && cutNode));

    Move      pv[MAX_PLY + 1];
    StateInfo st;
    ASSERT_ALIGNED(&st, Eval::NNUE::CacheLineSize);

    Key   posKey;
    Move  move, excludedMove, bestMove;
    Depth extension, newDepth;
    Value bestValue, value, eval, maxValue, probCutBeta;
    bool  givesCheck, improving, priorCapture, opponentWorsening;
    bool  capture, ttCapture;
    int   priorReduction = (ss - 1)->reduction;
    (ss - 1)->reduction  = 0;
    Piece movedPiece;

    ValueList<Move, 32> capturesSearched;
    ValueList<Move, 32> quietsSearched;

    // Step 1. Initialize node
    Worker* thisThread = this;
    ss->inCheck        = pos.checkers();
    priorCapture       = pos.captured_piece();
    Color us           = pos.side_to_move();
    ss->moveCount      = 0;
    bestValue          = -VALUE_INFINITE;
    maxValue           = VALUE_INFINITE;

    // Check for the available remaining time
    if (is_mainthread())
        main_manager()->check_time(*thisThread);

    // Used to send selDepth info to GUI (selDepth counts from 1, ply from 0)
    if (PvNode && thisThread->selDepth < ss->ply + 1)
        thisThread->selDepth = ss->ply + 1;

    if (!rootNode)
    {
        // Step 2. Check for aborted search and immediate draw
        if (threads.stop.load(std::memory_order_relaxed) || pos.is_draw(ss->ply)
            || ss->ply >= MAX_PLY)
            return (ss->ply >= MAX_PLY && !ss->inCheck) ? evaluate(pos)
                                                        : value_draw(thisThread->nodes);

        // Step 3. Mate distance pruning. Even if we mate at the next move our score
        // would be at best mate_in(ss->ply + 1), but if alpha is already bigger because
        // a shorter mate was found upward in the tree then there is no need to search
        // because we will never beat the current alpha. Same logic but with reversed
        // signs apply also in the opposite condition of being mated instead of giving
        // mate. In this case, return a fail-high score.
        alpha = std::max(mated_in(ss->ply), alpha);
        beta  = std::min(mate_in(ss->ply + 1), beta);
        if (alpha >= beta)
            return alpha;
    }

    assert(0 <= ss->ply && ss->ply < MAX_PLY);

    bestMove            = Move::none();
    (ss + 2)->cutoffCnt = 0;
    Square prevSq = ((ss - 1)->currentMove).is_ok() ? ((ss - 1)->currentMove).to_sq() : SQ_NONE;
    ss->statScore = 0;

    // Step 4. Transposition table lookup
    excludedMove                   = ss->excludedMove;
    posKey                         = pos.key();
    auto [ttHit, ttData, ttWriter] = tt.probe(posKey);
    // Need further processing of the saved data
    ss->ttHit    = ttHit;
    ttData.move  = rootNode ? thisThread->rootMoves[thisThread->pvIdx].pv[0]
                 : ttHit    ? ttData.move
                            : Move::none();
    ttData.value = ttHit ? value_from_tt(ttData.value, ss->ply, pos.rule50_count()) : VALUE_NONE;
    ss->ttPv     = excludedMove ? ss->ttPv : PvNode || (ttHit && ttData.is_pv);
    ttCapture    = ttData.move && pos.capture_stage(ttData.move);

    // At this point, if excluded, skip straight to step 6, static eval. However,
    // to save indentation, we list the condition in all code between here and there.

    // At non-PV nodes we check for an early TT cutoff
    if (!PvNode && !excludedMove && ttData.depth > depth - (ttData.value <= beta)
        && is_valid(ttData.value)  // Can happen when !ttHit or when access race in probe()
        && (ttData.bound & (ttData.value >= beta ? BOUND_LOWER : BOUND_UPPER))
        && (cutNode == (ttData.value >= beta) || depth > 5))
    {
        // If ttMove is quiet, update move sorting heuristics on TT hit
        if (ttData.move && ttData.value >= beta)
        {
            // Bonus for a quiet ttMove that fails high
            if (!ttCapture)
                update_quiet_histories(pos, ss, *this, ttData.move,
                                       std::min(117600 * depth - 71344, 1244992) / 1024);

            // Extra penalty for early quiet moves of the previous ply
            if (prevSq != SQ_NONE && (ss - 1)->moveCount <= 3 && !priorCapture)
                update_continuation_histories(ss - 1, pos.piece_on(prevSq), prevSq,
                                              -std::min(779788 * (depth + 1) - 271806, 2958308)
                                                / 1024);
        }

        // Partial workaround for the graph history interaction problem
        // For high rule50 counts don't produce transposition table cutoffs.
        if (pos.rule50_count() < 90)
            return ttData.value;
    }

    // Step 5. Tablebases probe
    if (!rootNode && !excludedMove && tbConfig.cardinality)
    {
        int piecesCount = pos.count<ALL_PIECES>();

        if (piecesCount <= tbConfig.cardinality
            && (piecesCount < tbConfig.cardinality || depth >= tbConfig.probeDepth)
            && pos.rule50_count() == 0 && !pos.can_castle(ANY_CASTLING))
        {
            TB::ProbeState err;
            TB::WDLScore   wdl = Tablebases::probe_wdl(pos, &err);

            // Force check of time on the next occasion
            if (is_mainthread())
                main_manager()->callsCnt = 0;

            if (err != TB::ProbeState::FAIL)
            {
                thisThread->tbHits.fetch_add(1, std::memory_order_relaxed);

                int drawScore = tbConfig.useRule50 ? 1 : 0;

                Value tbValue = VALUE_TB - ss->ply;

                // Use the range VALUE_TB to VALUE_TB_WIN_IN_MAX_PLY to score
                value = wdl < -drawScore ? -tbValue
                      : wdl > drawScore  ? tbValue
                                         : VALUE_DRAW + 2 * wdl * drawScore;

                Bound b = wdl < -drawScore ? BOUND_UPPER
                        : wdl > drawScore  ? BOUND_LOWER
                                           : BOUND_EXACT;

                if (b == BOUND_EXACT || (b == BOUND_LOWER ? value >= beta : value <= alpha))
                {
                    ttWriter.write(posKey, value_to_tt(value, ss->ply), ss->ttPv, b,
                                   std::min(MAX_PLY - 1, depth + 6), Move::none(), VALUE_NONE,
                                   tt.generation());

                    return value;
                }

                if (PvNode)
                {
                    if (b == BOUND_LOWER)
                        bestValue = value, alpha = std::max(alpha, bestValue);
                    else
                        maxValue = value;
                }
            }
        }
    }

    // Step 6. Static evaluation of the position
    Value      unadjustedStaticEval = VALUE_NONE;
    const auto correctionValue      = correction_value(*thisThread, pos, ss);
    if (ss->inCheck)
    {
        // Skip early pruning when in check
        ss->staticEval = eval = (ss - 2)->staticEval;
        improving             = false;
        goto moves_loop;
    }
    else if (excludedMove)
    {
        // Providing the hint that this node's accumulator will be used often
        unadjustedStaticEval = eval = ss->staticEval;
    }
    else if (ss->ttHit)
    {
        // Never assume anything about values stored in TT
        unadjustedStaticEval = ttData.eval;
        if (!is_valid(unadjustedStaticEval))
            unadjustedStaticEval = evaluate(pos);

        ss->staticEval = eval = to_corrected_static_eval(unadjustedStaticEval, correctionValue);

        // ttValue can be used as a better position evaluation
        if (is_valid(ttData.value)
            && (ttData.bound & (ttData.value > eval ? BOUND_LOWER : BOUND_UPPER)))
            eval = ttData.value;
    }
    else
    {
        unadjustedStaticEval = evaluate(pos);
        ss->staticEval = eval = to_corrected_static_eval(unadjustedStaticEval, correctionValue);

        // Static evaluation is saved as it was before adjustment by correction history
        ttWriter.write(posKey, VALUE_NONE, ss->ttPv, BOUND_NONE, DEPTH_UNSEARCHED, Move::none(),
                       unadjustedStaticEval, tt.generation());
    }

    // Use static evaluation difference to improve quiet move ordering
    if (((ss - 1)->currentMove).is_ok() && !(ss - 1)->inCheck && !priorCapture)
    {
        int bonus = std::clamp(-10 * int((ss - 1)->staticEval + ss->staticEval), -1906, 1450) + 638;
        thisThread->mainHistory[~us][((ss - 1)->currentMove).from_to()] << bonus * 1136 / 1024;
        if (type_of(pos.piece_on(prevSq)) != PAWN && ((ss - 1)->currentMove).type_of() != PROMOTION)
            thisThread->pawnHistory[pawn_structure_index(pos)][pos.piece_on(prevSq)][prevSq]
              << bonus * 1195 / 1024;
    }

    // Set up the improving flag, which is true if current static evaluation is
    // bigger than the previous static evaluation at our turn (if we were in
    // check at our previous move we go back until we weren't in check) and is
    // false otherwise. The improving flag is used in various pruning heuristics.
    improving = ss->staticEval > (ss - 2)->staticEval;

    opponentWorsening = ss->staticEval > -(ss - 1)->staticEval;

    if (priorReduction >= 3 && !opponentWorsening)
        depth++;
    if (priorReduction >= 1 && depth >= 2 && ss->staticEval + (ss - 1)->staticEval > 200)
        depth--;

    // Step 7. Razoring
    // If eval is really low, skip search entirely and return the qsearch value.
    // For PvNodes, we must have a guard against mates being returned.
    if (!PvNode && eval < alpha - 446 - 303 * depth * depth)
        return qsearch<NonPV>(pos, ss, alpha, beta);

    // Step 8. Futility pruning: child node
    // The depth condition is important for mate finding.
    if (!ss->ttPv && depth < 14
        && eval - futility_margin(depth, cutNode && !ss->ttHit, improving, opponentWorsening)
               - (ss - 1)->statScore / 326 + 37 - std::abs(correctionValue) / 132821
             >= beta
        && eval >= beta && (!ttData.move || ttCapture) && !is_loss(beta) && !is_win(eval))
        return beta + (eval - beta) / 3;

    // Step 9. Null move search with verification search
    if (cutNode && (ss - 1)->currentMove != Move::null() && eval >= beta
        && ss->staticEval >= beta - 21 * depth + 455 - 60 * improving && !excludedMove
        && pos.non_pawn_material(us) && ss->ply >= thisThread->nmpMinPly && !is_loss(beta))
    {
        assert(eval - beta >= 0);

        // Null move dynamic reduction based on depth and eval
        Depth R = std::min(int(eval - beta) / 237, 6) + depth / 3 + 5;

        ss->currentMove                   = Move::null();
        ss->continuationHistory           = &thisThread->continuationHistory[0][0][NO_PIECE][0];
        ss->continuationCorrectionHistory = &thisThread->continuationCorrectionHistory[NO_PIECE][0];

        pos.do_null_move(st, tt);

        Value nullValue = -search<NonPV>(pos, ss + 1, -beta, -beta + 1, depth - R, false);

        pos.undo_null_move();

        // Do not return unproven mate or TB scores
        if (nullValue >= beta && !is_win(nullValue))
        {
            if (thisThread->nmpMinPly || depth < 16)
                return nullValue;

            assert(!thisThread->nmpMinPly);  // Recursive verification is not allowed

            // Do verification search at high depths, with null move pruning disabled
            // until ply exceeds nmpMinPly.
            thisThread->nmpMinPly = ss->ply + 3 * (depth - R) / 4;

            Value v = search<NonPV>(pos, ss, beta - 1, beta, depth - R, false);

            thisThread->nmpMinPly = 0;

            if (v >= beta)
                return nullValue;
        }
    }

    improving |= ss->staticEval >= beta + 97;

    // Step 10. Internal iterative reductions
    // For PV nodes without a ttMove as well as for deep enough cutNodes, we decrease depth.
    // (* Scaler) Especially if they make IIR more aggressive.
    if (((PvNode || cutNode) && depth >= 7 - 3 * PvNode) && !ttData.move)
        depth--;

    // Step 11. ProbCut
    // If we have a good enough capture (or queen promotion) and a reduced search
    // returns a value much above beta, we can (almost) safely prune the previous move.
    probCutBeta = beta + 187 - 55 * improving;
    if (depth >= 3
        && !is_decisive(beta)
        // If value from transposition table is lower than probCutBeta, don't attempt
        // probCut there and in further interactions with transposition table cutoff
        // depth is set to depth - 3 because probCut search has depth set to depth - 4
        // but we also do a move before it. So effective depth is equal to depth - 3.
        && !(is_valid(ttData.value) && ttData.value < probCutBeta))
    {
        assert(probCutBeta < VALUE_INFINITE && probCutBeta > beta);

        MovePicker mp(pos, ttData.move, probCutBeta - ss->staticEval, &thisThread->captureHistory);
        Depth      probCutDepth = std::max(depth - 4, 0);

        while ((move = mp.next_move()) != Move::none())
        {
            assert(move.is_ok());

            if (move == excludedMove)
                continue;

            if (!pos.legal(move))
                continue;

            assert(pos.capture_stage(move));

            movedPiece = pos.moved_piece(move);

            pos.do_move(move, st, &tt);
            thisThread->nodes.fetch_add(1, std::memory_order_relaxed);

            ss->currentMove = move;
            ss->isTTMove    = (move == ttData.move);
            ss->continuationHistory =
              &this->continuationHistory[ss->inCheck][true][movedPiece][move.to_sq()];
            ss->continuationCorrectionHistory =
              &this->continuationCorrectionHistory[movedPiece][move.to_sq()];

            // Perform a preliminary qsearch to verify that the move holds
            value = -qsearch<NonPV>(pos, ss + 1, -probCutBeta, -probCutBeta + 1);

            // If the qsearch held, perform the regular search
            if (value >= probCutBeta && probCutDepth > 0)
                value = -search<NonPV>(pos, ss + 1, -probCutBeta, -probCutBeta + 1, probCutDepth,
                                       !cutNode);

            pos.undo_move(move);

            if (value >= probCutBeta)
            {
                // Save ProbCut data into transposition table
                ttWriter.write(posKey, value_to_tt(value, ss->ply), ss->ttPv, BOUND_LOWER,
                               probCutDepth + 1, move, unadjustedStaticEval, tt.generation());

                if (!is_decisive(value))
                    return value - (probCutBeta - beta);
            }
        }
    }

moves_loop:  // When in check, search starts here

    // Step 12. A small Probcut idea
    probCutBeta = beta + 413;
    if ((ttData.bound & BOUND_LOWER) && ttData.depth >= depth - 4 && ttData.value >= probCutBeta
        && !is_decisive(beta) && is_valid(ttData.value) && !is_decisive(ttData.value))
        return probCutBeta;

    const PieceToHistory* contHist[] = {
      (ss - 1)->continuationHistory, (ss - 2)->continuationHistory, (ss - 3)->continuationHistory,
      (ss - 4)->continuationHistory, (ss - 5)->continuationHistory, (ss - 6)->continuationHistory};


    MovePicker mp(pos, ttData.move, depth, &thisThread->mainHistory, &thisThread->lowPlyHistory,
                  &thisThread->captureHistory, contHist, &thisThread->pawnHistory, ss->ply);

    value = bestValue;

    int moveCount = 0;

    // Step 13. Loop through all pseudo-legal moves until no moves remain
    // or a beta cutoff occurs.
    while ((move = mp.next_move()) != Move::none())
    {
        assert(move.is_ok());

        if (move == excludedMove)
            continue;

        // Check for legality
        if (!pos.legal(move))
            continue;

        // At root obey the "searchmoves" option and skip moves not listed in Root
        // Move List. In MultiPV mode we also skip PV moves that have been already
        // searched and those of lower "TB rank" if we are in a TB root position.
        if (rootNode
            && !std::count(thisThread->rootMoves.begin() + thisThread->pvIdx,
                           thisThread->rootMoves.begin() + thisThread->pvLast, move))
            continue;

        ss->moveCount = ++moveCount;

        if (rootNode && is_mainthread() && nodes > 10000000)
        {
            main_manager()->updates.onIter(
              {depth, UCIEngine::move(move, pos.is_chess960()), moveCount + thisThread->pvIdx});
        }
        if (PvNode)
            (ss + 1)->pv = nullptr;

        extension  = 0;
        capture    = pos.capture_stage(move);
        movedPiece = pos.moved_piece(move);
        givesCheck = pos.gives_check(move);

        // Calculate new depth for this move
        newDepth = depth - 1;

        int delta = beta - alpha;

        Depth r = reduction(improving, depth, moveCount, delta);

        r -= 32 * moveCount;

        // Increase reduction for ttPv nodes (*Scaler)
        // Smaller or even negative value is better for short time controls
        // Bigger value is better for long time controls
        if (ss->ttPv)
            r += 1031;

        // Step 14. Pruning at shallow depth.
        // Depth conditions are important for mate finding.
        if (!rootNode && pos.non_pawn_material(us) && !is_loss(bestValue))
        {
            // Skip quiet moves if movecount exceeds our FutilityMoveCount threshold
            if (moveCount >= futility_move_count(improving, depth))
                mp.skip_quiet_moves();

            // Reduced depth of the next LMR search
            int lmrDepth = newDepth - r / 1024;

            if (capture || givesCheck)
            {
                Piece capturedPiece = pos.piece_on(move.to_sq());
                int   captHist =
                  thisThread->captureHistory[movedPiece][move.to_sq()][type_of(capturedPiece)];

                // Futility pruning for captures
                if (!givesCheck && lmrDepth < 7 && !ss->inCheck)
                {
                    Value futilityValue = ss->staticEval + 242 + 238 * lmrDepth
                                        + PieceValue[capturedPiece] + 95 * captHist / 700;
                    if (futilityValue <= alpha)
                        continue;
                }

                // SEE based pruning for captures and checks
                int seeHist = std::clamp(captHist / 36, -153 * depth, 134 * depth);
                if (!pos.see_ge(move, -157 * depth - seeHist))
                    continue;
            }
            else
            {
                int history =
                  (*contHist[0])[movedPiece][move.to_sq()]
                  + (*contHist[1])[movedPiece][move.to_sq()]
                  + thisThread->pawnHistory[pawn_structure_index(pos)][movedPiece][move.to_sq()];

                // Continuation history based pruning
                if (history < -4107 * depth)
                    continue;

                history += 68 * thisThread->mainHistory[us][move.from_to()] / 32;

                lmrDepth += history / 3576;

                Value futilityValue = ss->staticEval + (bestMove ? 49 : 143) + 116 * lmrDepth;

                if (bestValue < ss->staticEval - 150 && lmrDepth < 7)
                    futilityValue += 108;

                // Futility pruning: parent node
                // (*Scaler): Generally, more frequent futility pruning
                // scales well with respect to time and threads
                if (!ss->inCheck && lmrDepth < 12 && futilityValue <= alpha)
                {
                    if (bestValue <= futilityValue && !is_decisive(bestValue)
                        && !is_win(futilityValue))
                        bestValue = futilityValue;
                    continue;
                }

                lmrDepth = std::max(lmrDepth, 0);

                // Prune moves with negative SEE
                if (!pos.see_ge(move, -26 * lmrDepth * lmrDepth))
                    continue;
            }
        }

        // Step 15. Extensions
        // We take care to not overdo to avoid search getting stuck.
        if (ss->ply < thisThread->rootDepth * 2)
        {
            // Singular extension search. If all moves but one
            // fail low on a search of (alpha-s, beta-s), and just one fails high on
            // (alpha, beta), then that move is singular and should be extended. To
            // verify this we do a reduced search on the position excluding the ttMove
            // and if the result is lower than ttValue minus a margin, then we will
            // extend the ttMove. Recursive singular search is avoided.

            // (* Scaler) Generally, higher singularBeta (i.e closer to ttValue)
            // and lower extension margins scale well.

            if (!rootNode && move == ttData.move && !excludedMove
                && depth >= 5 - (thisThread->completedDepth > 32) + ss->ttPv
                && is_valid(ttData.value) && !is_decisive(ttData.value)
                && (ttData.bound & BOUND_LOWER) && ttData.depth >= depth - 3)
            {
                Value singularBeta  = ttData.value - (55 + 81 * (ss->ttPv && !PvNode)) * depth / 58;
                Depth singularDepth = newDepth / 2;

                ss->excludedMove = move;
                value =
                  search<NonPV>(pos, ss, singularBeta - 1, singularBeta, singularDepth, cutNode);
                ss->excludedMove = Move::none();

                if (value < singularBeta)
                {
                    int corrValAdj1  = std::abs(correctionValue) / 265083;
                    int corrValAdj2  = std::abs(correctionValue) / 253680;
                    int doubleMargin = 267 * PvNode - 181 * !ttCapture - corrValAdj1;
                    int tripleMargin =
                      96 + 282 * PvNode - 250 * !ttCapture + 103 * ss->ttPv - corrValAdj2;

                    extension = 1 + (value < singularBeta - doubleMargin)
                              + (value < singularBeta - tripleMargin);

                    depth++;
                }

                // Multi-cut pruning
                // Our ttMove is assumed to fail high based on the bound of the TT entry,
                // and if after excluding the ttMove with a reduced search we fail high
                // over the original beta, we assume this expected cut-node is not
                // singular (multiple moves fail high), and we can prune the whole
                // subtree by returning a softbound.
                else if (value >= beta && !is_decisive(value))
                    return value;

                // Negative extensions
                // If other moves failed high over (ttValue - margin) without the
                // ttMove on a reduced search, but we cannot do multi-cut because
                // (ttValue - margin) is lower than the original beta, we do not know
                // if the ttMove is singular or can do a multi-cut, so we reduce the
                // ttMove in favor of other moves based on some conditions:

                // If the ttMove is assumed to fail high over current beta
                else if (ttData.value >= beta)
                    extension = -3;

                // If we are on a cutNode but the ttMove is not assumed to fail high
                // over current beta
                else if (cutNode)
                    extension = -2;
            }
        }

        // Step 16. Make the move
        pos.do_move(move, st, givesCheck, &tt);
        thisThread->nodes.fetch_add(1, std::memory_order_relaxed);

        // Add extension to new depth
        newDepth += extension;

        // Update the current move (this must be done after singular extension search)
        ss->currentMove = move;
        ss->isTTMove    = (move == ttData.move);
        ss->continuationHistory =
          &thisThread->continuationHistory[ss->inCheck][capture][movedPiece][move.to_sq()];
        ss->continuationCorrectionHistory =
          &thisThread->continuationCorrectionHistory[movedPiece][move.to_sq()];
        uint64_t nodeCount = rootNode ? uint64_t(nodes) : 0;

        // Decrease reduction for PvNodes (*Scaler)
        if (ss->ttPv)
            r -= 2230 + PvNode * 1013 + (ttData.value > alpha) * 925
               + (ttData.depth >= depth) * (971 + cutNode * 1159);

        // These reduction adjustments have no proven non-linear scaling

        r += 316 - moveCount * 32;

        r -= std::abs(correctionValue) / 31568;

        if (PvNode && !is_decisive(bestValue))
            r -= risk_tolerance(pos, bestValue);

        // Increase reduction for cut nodes
        if (cutNode)
            r += 2608 + 1024 * !ttData.move;

        // Increase reduction if ttMove is a capture but the current move is not a capture
        if (ttCapture && !capture)
            r += 1123 + (depth < 8) * 982;

        // Increase reduction if next ply has a lot of fail high
        if ((ss + 1)->cutoffCnt > 3)
            r += 981 + allNode * 833;

        // For first picked move (ttMove) reduce reduction
        else if (move == ttData.move)
            r -= 1982;

        if (capture)
            ss->statScore =
              688 * int(PieceValue[pos.captured_piece()]) / 100
              + thisThread->captureHistory[movedPiece][move.to_sq()][type_of(pos.captured_piece())]
              - 4653;
        else
            ss->statScore = 2 * thisThread->mainHistory[us][move.from_to()]
                          + (*contHist[0])[movedPiece][move.to_sq()]
                          + (*contHist[1])[movedPiece][move.to_sq()] - 3591;

        // Decrease/increase reduction for moves with a good/bad history
        r -= ss->statScore * 1407 / 16384;

        // Step 17. Late moves reduction / extension (LMR)
        if (depth >= 2 && moveCount > 1)
        {
            // In general we want to cap the LMR depth search at newDepth, but when
            // reduction is negative, we allow this move a limited search extension
            // beyond the first move depth.
            // To prevent problems when the max value is less than the min value,
            // std::clamp has been replaced by a more robust implementation.


            Depth d = std::max(
              1, std::min(newDepth - r / 1024, newDepth + !allNode + (PvNode && !bestMove)));

            ss->reduction = newDepth - d;

            value         = -search<NonPV>(pos, ss + 1, -(alpha + 1), -alpha, d, true);
            ss->reduction = 0;


            // Do a full-depth search when reduced LMR search fails high
            if (value > alpha && d < newDepth)
            {
                // Adjust full-depth search based on LMR results - if the result was
                // good enough search deeper, if it was bad enough search shallower.
                const bool doDeeperSearch    = value > (bestValue + 41 + 2 * newDepth);
                const bool doShallowerSearch = value < bestValue + 9;

                newDepth += doDeeperSearch - doShallowerSearch;

                if (newDepth > d)
                    value = -search<NonPV>(pos, ss + 1, -(alpha + 1), -alpha, newDepth, !cutNode);

                // Post LMR continuation history updates
                int bonus = (value >= beta) * 2010;
                update_continuation_histories(ss, movedPiece, move.to_sq(), bonus);
            }
            else if (value > alpha && value < bestValue + 9)
                newDepth--;
        }

        // Step 18. Full-depth search when LMR is skipped
        else if (!PvNode || moveCount > 1)
        {
            // Increase reduction if ttMove is not present
            if (!ttData.move)
                r += 1111;

            // Note that if expected reduction is high, we reduce search depth here
            value = -search<NonPV>(pos, ss + 1, -(alpha + 1), -alpha,
                                   newDepth - (r > 3554) - (r > 5373 && newDepth > 2), !cutNode);
        }

        // For PV nodes only, do a full PV search on the first move or after a fail high,
        // otherwise let the parent node fail low with value <= alpha and try another move.
        if (PvNode && (moveCount == 1 || value > alpha))
        {
            (ss + 1)->pv    = pv;
            (ss + 1)->pv[0] = Move::none();

            // Extend move from transposition table if we are about to dive into qsearch.
            if (move == ttData.move && thisThread->rootDepth > 8)
                newDepth = std::max(newDepth, 1);

            value = -search<PV>(pos, ss + 1, -beta, -alpha, newDepth, false);
        }

        // Step 19. Undo move
        pos.undo_move(move);

        assert(value > -VALUE_INFINITE && value < VALUE_INFINITE);

        // Step 20. Check for a new best move
        // Finished searching the move. If a stop occurred, the return value of
        // the search cannot be trusted, and we return immediately without updating
        // best move, principal variation nor transposition table.
        if (threads.stop.load(std::memory_order_relaxed))
            return VALUE_ZERO;

        if (rootNode)
        {
            RootMove& rm =
              *std::find(thisThread->rootMoves.begin(), thisThread->rootMoves.end(), move);

            rm.effort += nodes - nodeCount;

            rm.averageScore =
              rm.averageScore != -VALUE_INFINITE ? (value + rm.averageScore) / 2 : value;

            rm.meanSquaredScore = rm.meanSquaredScore != -VALUE_INFINITE * VALUE_INFINITE
                                  ? (value * std::abs(value) + rm.meanSquaredScore) / 2
                                  : value * std::abs(value);

            // PV move or new best move?
            if (moveCount == 1 || value > alpha)
            {
                rm.score = rm.uciScore = value;
                rm.selDepth            = thisThread->selDepth;
                rm.scoreLowerbound = rm.scoreUpperbound = false;

                if (value >= beta)
                {
                    rm.scoreLowerbound = true;
                    rm.uciScore        = beta;
                }
                else if (value <= alpha)
                {
                    rm.scoreUpperbound = true;
                    rm.uciScore        = alpha;
                }

                rm.pv.resize(1);

                assert((ss + 1)->pv);

                for (Move* m = (ss + 1)->pv; *m != Move::none(); ++m)
                    rm.pv.push_back(*m);

                // We record how often the best move has been changed in each iteration.
                // This information is used for time management. In MultiPV mode,
                // we must take care to only do this for the first PV line.
                if (moveCount > 1 && !thisThread->pvIdx)
                    ++thisThread->bestMoveChanges;
            }
            else
                // All other moves but the PV, are set to the lowest value: this
                // is not a problem when sorting because the sort is stable and the
                // move position in the list is preserved - just the PV is pushed up.
                rm.score = -VALUE_INFINITE;
        }

        // In case we have an alternative move equal in eval to the current bestmove,
        // promote it to bestmove by pretending it just exceeds alpha (but not beta).
        int inc = (value == bestValue && ss->ply + 2 >= thisThread->rootDepth
                   && (int(nodes) & 15) == 0 && !is_win(std::abs(value) + 1));

        if (value + inc > bestValue)
        {
            bestValue = value;

            if (value + inc > alpha)
            {
                bestMove = move;

                if (PvNode && !rootNode)  // Update pv even in fail-high case
                    update_pv(ss->pv, move, (ss + 1)->pv);

                if (value >= beta)
                {
                    // (* Scaler) Especially if they make cutoffCnt increment more often.
                    ss->cutoffCnt += (extension < 2) || PvNode;
                    assert(value >= beta);  // Fail high
                    break;
                }
                else
                {
                    // Reduce other moves if we have found at least one score improvement
                    if (depth > 2 && depth < 15 && !is_decisive(value))
                        depth -= 2;

                    assert(depth > 0);
                    alpha = value;  // Update alpha! Always alpha < beta
                }
            }
        }

        // If the move is worse than some previously searched move,
        // remember it, to update its stats later.
        if (move != bestMove && moveCount <= 32)
        {
            if (capture)
                capturesSearched.push_back(move);
            else
                quietsSearched.push_back(move);
        }
    }

    // Step 21. Check for mate and stalemate
    // All legal moves have been searched and if there are no legal moves, it
    // must be a mate or a stalemate. If we are in a singular extension search then
    // return a fail low score.

    assert(moveCount || !ss->inCheck || excludedMove || !MoveList<LEGAL>(pos).size());

    // Adjust best value for fail high cases at non-pv nodes
    if (!PvNode && bestValue >= beta && !is_decisive(bestValue) && !is_decisive(beta)
        && !is_decisive(alpha))
        bestValue = (bestValue * depth + beta) / (depth + 1);

    if (!moveCount)
        bestValue = excludedMove ? alpha : ss->inCheck ? mated_in(ss->ply) : VALUE_DRAW;

    // If there is a move that produces search value greater than alpha,
    // we update the stats of searched moves.
    else if (bestMove)
        update_all_stats(pos, ss, *this, bestMove, prevSq, quietsSearched, capturesSearched, depth,
                         bestMove == ttData.move, moveCount);

    // Bonus for prior countermove that caused the fail low
    else if (!priorCapture && prevSq != SQ_NONE)
    {
        int bonusScale = (118 * (depth > 5) + 36 * !allNode + 161 * ((ss - 1)->moveCount > 8)
                          + 133 * (!ss->inCheck && bestValue <= ss->staticEval - 107)
                          + 120 * (!(ss - 1)->inCheck && bestValue <= -(ss - 1)->staticEval - 84)
                          + 81 * ((ss - 1)->isTTMove) + 100 * (ss->cutoffCnt <= 3)
                          + std::min(-(ss - 1)->statScore / 108, 320));

        bonusScale = std::max(bonusScale, 0);

        const int scaledBonus = std::min(160 * depth - 106, 1523) * bonusScale;

        update_continuation_histories(ss - 1, pos.piece_on(prevSq), prevSq,
                                      scaledBonus * 416 / 32768);

        thisThread->mainHistory[~us][((ss - 1)->currentMove).from_to()]
          << scaledBonus * 219 / 32768;

        if (type_of(pos.piece_on(prevSq)) != PAWN && ((ss - 1)->currentMove).type_of() != PROMOTION)
            thisThread->pawnHistory[pawn_structure_index(pos)][pos.piece_on(prevSq)][prevSq]
              << scaledBonus * 1103 / 32768;
    }

    else if (priorCapture && prevSq != SQ_NONE)
    {
        // bonus for prior countermoves that caused the fail low
        Piece capturedPiece = pos.captured_piece();
        assert(capturedPiece != NO_PIECE);
        thisThread->captureHistory[pos.piece_on(prevSq)][prevSq][type_of(capturedPiece)]
          << std::min(330 * depth - 198, 3320);
    }

    if (PvNode)
        bestValue = std::min(bestValue, maxValue);

    // If no good move is found and the previous position was ttPv, then the previous
    // opponent move is probably good and the new position is added to the search tree.
    if (bestValue <= alpha)
        ss->ttPv = ss->ttPv || (ss - 1)->ttPv;

    // Write gathered information in transposition table. Note that the
    // static evaluation is saved as it was before correction history.
    if (!excludedMove && !(rootNode && thisThread->pvIdx))
        ttWriter.write(posKey, value_to_tt(bestValue, ss->ply), ss->ttPv,
                       bestValue >= beta    ? BOUND_LOWER
                       : PvNode && bestMove ? BOUND_EXACT
                                            : BOUND_UPPER,
                       depth, bestMove, unadjustedStaticEval, tt.generation());

    // Adjust correction history
    if (!ss->inCheck && !(bestMove && pos.capture(bestMove))
        && ((bestValue < ss->staticEval && bestValue < beta)  // negative correction & no fail high
            || (bestValue > ss->staticEval && bestMove)))     // positive correction & no fail low
    {
        auto bonus = std::clamp(int(bestValue - ss->staticEval) * depth / 8,
                                -CORRECTION_HISTORY_LIMIT / 4, CORRECTION_HISTORY_LIMIT / 4);
        update_correction_history(pos, ss, *thisThread, bonus);
    }

    assert(bestValue > -VALUE_INFINITE && bestValue < VALUE_INFINITE);

    return bestValue;
}


// Quiescence search function, which is called by the main search function with
// depth zero, or recursively with further decreasing depth. With depth <= 0, we
// "should" be using static eval only, but tactical moves may confuse the static eval.
// To fight this horizon effect, we implement this qsearch of tactical moves.
// See https://www.chessprogramming.org/Horizon_Effect
// and https://www.chessprogramming.org/Quiescence_Search
template<NodeType nodeType>
Value Search::Worker::qsearch(Position& pos, Stack* ss, Value alpha, Value beta) {

    static_assert(nodeType != Root);
    constexpr bool PvNode = nodeType == PV;

    assert(alpha >= -VALUE_INFINITE && alpha < beta && beta <= VALUE_INFINITE);
    assert(PvNode || (alpha == beta - 1));

    // Check if we have an upcoming move that draws by repetition
    if (alpha < VALUE_DRAW && pos.upcoming_repetition(ss->ply))
    {
        alpha = value_draw(this->nodes);
        if (alpha >= beta)
            return alpha;
    }

    Move      pv[MAX_PLY + 1];
    StateInfo st;
    ASSERT_ALIGNED(&st, Eval::NNUE::CacheLineSize);

    Key   posKey;
    Move  move, bestMove;
    Value bestValue, value, futilityBase;
    bool  pvHit, givesCheck, capture;
    int   moveCount;

    // Step 1. Initialize node
    if (PvNode)
    {
        (ss + 1)->pv = pv;
        ss->pv[0]    = Move::none();
    }

    Worker* thisThread = this;
    bestMove           = Move::none();
    ss->inCheck        = pos.checkers();
    moveCount          = 0;

    // Used to send selDepth info to GUI (selDepth counts from 1, ply from 0)
    if (PvNode && thisThread->selDepth < ss->ply + 1)
        thisThread->selDepth = ss->ply + 1;

    // Step 2. Check for an immediate draw or maximum ply reached
    if (pos.is_draw(ss->ply) || ss->ply >= MAX_PLY)
        return (ss->ply >= MAX_PLY && !ss->inCheck) ? evaluate(pos) : VALUE_DRAW;

    assert(0 <= ss->ply && ss->ply < MAX_PLY);

    // Step 3. Transposition table lookup
    posKey                         = pos.key();
    auto [ttHit, ttData, ttWriter] = tt.probe(posKey);
    // Need further processing of the saved data
    ss->ttHit    = ttHit;
    ttData.move  = ttHit ? ttData.move : Move::none();
    ttData.value = ttHit ? value_from_tt(ttData.value, ss->ply, pos.rule50_count()) : VALUE_NONE;
    pvHit        = ttHit && ttData.is_pv;

    // At non-PV nodes we check for an early TT cutoff
    if (!PvNode && ttData.depth >= DEPTH_QS
        && is_valid(ttData.value)  // Can happen when !ttHit or when access race in probe()
        && (ttData.bound & (ttData.value >= beta ? BOUND_LOWER : BOUND_UPPER)))
        return ttData.value;

    // Step 4. Static evaluation of the position
    Value      unadjustedStaticEval = VALUE_NONE;
    const auto correctionValue      = correction_value(*thisThread, pos, ss);
    if (ss->inCheck)
        bestValue = futilityBase = -VALUE_INFINITE;
    else
    {
        if (ss->ttHit)
        {
            // Never assume anything about values stored in TT
            unadjustedStaticEval = ttData.eval;
            if (!is_valid(unadjustedStaticEval))
                unadjustedStaticEval = evaluate(pos);
            ss->staticEval = bestValue =
              to_corrected_static_eval(unadjustedStaticEval, correctionValue);

            // ttValue can be used as a better position evaluation
            if (is_valid(ttData.value) && !is_decisive(ttData.value)
                && (ttData.bound & (ttData.value > bestValue ? BOUND_LOWER : BOUND_UPPER)))
                bestValue = ttData.value;
        }
        else
        {
            // In case of null move search, use previous static eval with opposite sign
            unadjustedStaticEval =
              (ss - 1)->currentMove != Move::null() ? evaluate(pos) : -(ss - 1)->staticEval;
            ss->staticEval = bestValue =
              to_corrected_static_eval(unadjustedStaticEval, correctionValue);
        }

        // Stand pat. Return immediately if static value is at least beta
        if (bestValue >= beta)
        {
            if (!is_decisive(bestValue))
                bestValue = (bestValue + beta) / 2;
            if (!ss->ttHit)
                ttWriter.write(posKey, value_to_tt(bestValue, ss->ply), false, BOUND_LOWER,
                               DEPTH_UNSEARCHED, Move::none(), unadjustedStaticEval,
                               tt.generation());
            return bestValue;
        }

        if (bestValue > alpha)
            alpha = bestValue;

        futilityBase = ss->staticEval + 325;
    }

    const PieceToHistory* contHist[] = {(ss - 1)->continuationHistory,
                                        (ss - 2)->continuationHistory};

    Square prevSq = ((ss - 1)->currentMove).is_ok() ? ((ss - 1)->currentMove).to_sq() : SQ_NONE;

    // Initialize a MovePicker object for the current position, and prepare to search
    // the moves. We presently use two stages of move generator in quiescence search:
    // captures, or evasions only when in check.
    MovePicker mp(pos, ttData.move, DEPTH_QS, &thisThread->mainHistory, &thisThread->lowPlyHistory,
                  &thisThread->captureHistory, contHist, &thisThread->pawnHistory, ss->ply);

    // Step 5. Loop through all pseudo-legal moves until no moves remain or a beta
    // cutoff occurs.
    while ((move = mp.next_move()) != Move::none())
    {
        assert(move.is_ok());

        if (!pos.legal(move))
            continue;

        givesCheck = pos.gives_check(move);
        capture    = pos.capture_stage(move);

        moveCount++;

        // Step 6. Pruning
        if (!is_loss(bestValue))
        {
            // Futility pruning and moveCount pruning
            if (!givesCheck && move.to_sq() != prevSq && !is_loss(futilityBase)
                && move.type_of() != PROMOTION)
            {
                if (moveCount > 2)
                    continue;

                Value futilityValue = futilityBase + PieceValue[pos.piece_on(move.to_sq())];

                // If static eval + value of piece we are going to capture is
                // much lower than alpha, we can prune this move.
                if (futilityValue <= alpha)
                {
                    bestValue = std::max(bestValue, futilityValue);
                    continue;
                }

                // If static exchange evaluation is low enough
                // we can prune this move.
                if (!pos.see_ge(move, alpha - futilityBase))
                {
                    bestValue = std::min(alpha, futilityBase);
                    continue;
                }
            }

            // Continuation history based pruning
            if (!capture
                && (*contHist[0])[pos.moved_piece(move)][move.to_sq()]
                       + (*contHist[1])[pos.moved_piece(move)][move.to_sq()]
                       + thisThread->pawnHistory[pawn_structure_index(pos)][pos.moved_piece(move)]
                                                [move.to_sq()]
                     <= 5389)
                continue;

            // Do not search moves with bad enough SEE values
            if (!pos.see_ge(move, -75))
                continue;
        }

        // Step 7. Make and search the move
        Piece movedPiece = pos.moved_piece(move);

        pos.do_move(move, st, givesCheck, &tt);
        thisThread->nodes.fetch_add(1, std::memory_order_relaxed);

        // Update the current move
        ss->currentMove = move;
        ss->continuationHistory =
          &thisThread->continuationHistory[ss->inCheck][capture][movedPiece][move.to_sq()];
        ss->continuationCorrectionHistory =
          &thisThread->continuationCorrectionHistory[movedPiece][move.to_sq()];

        value = -qsearch<nodeType>(pos, ss + 1, -beta, -alpha);
        pos.undo_move(move);

        assert(value > -VALUE_INFINITE && value < VALUE_INFINITE);

        // Step 8. Check for a new best move
        if (value > bestValue)
        {
            bestValue = value;

            if (value > alpha)
            {
                bestMove = move;

                if (PvNode)  // Update pv even in fail-high case
                    update_pv(ss->pv, move, (ss + 1)->pv);

                if (value < beta)  // Update alpha here!
                    alpha = value;
                else
                    break;  // Fail high
            }
        }
    }

    // Step 9. Check for mate
    // All legal moves have been searched. A special case: if we are
    // in check and no legal moves were found, it is checkmate.
    if (ss->inCheck && bestValue == -VALUE_INFINITE)
    {
        assert(!MoveList<LEGAL>(pos).size());
        return mated_in(ss->ply);  // Plies to mate from the root
    }

    if (!is_decisive(bestValue) && bestValue > beta)
        bestValue = (bestValue + beta) / 2;

    // Save gathered info in transposition table. The static evaluation
    // is saved as it was before adjustment by correction history.
    ttWriter.write(posKey, value_to_tt(bestValue, ss->ply), pvHit,
                   bestValue >= beta ? BOUND_LOWER : BOUND_UPPER, DEPTH_QS, bestMove,
                   unadjustedStaticEval, tt.generation());

    assert(bestValue > -VALUE_INFINITE && bestValue < VALUE_INFINITE);

    return bestValue;
}

Depth Search::Worker::reduction(bool i, Depth d, int mn, int delta) const {
    int reductionScale = reductions[d] * reductions[mn];
    return reductionScale - delta * 735 / rootDelta + !i * reductionScale * 191 / 512 + 1132;
}

// elapsed() returns the time elapsed since the search started. If the
// 'nodestime' option is enabled, it will return the count of nodes searched
// instead. This function is called to check whether the search should be
// stopped based on predefined thresholds like time limits or nodes searched.
//
// elapsed_time() returns the actual time elapsed since the start of the search.
// This function is intended for use only when printing PV outputs, and not used
// for making decisions within the search algorithm itself.
TimePoint Search::Worker::elapsed() const {
    return main_manager()->tm.elapsed([this]() { return threads.nodes_searched(); });
}

TimePoint Search::Worker::elapsed_time() const { return main_manager()->tm.elapsed_time(); }

Value Search::Worker::evaluate(const Position& pos) {
    return Eval::evaluate(networks[numaAccessToken], pos, refreshTable,
                          optimism[pos.side_to_move()]);
}

namespace {
// Adjusts a mate or TB score from "plies to mate from the root" to
// "plies to mate from the current position". Standard scores are unchanged.
// The function is called before storing a value in the transposition table.
Value value_to_tt(Value v, int ply) { return is_win(v) ? v + ply : is_loss(v) ? v - ply : v; }


// Inverse of value_to_tt(): it adjusts a mate or TB score from the transposition
// table (which refers to the plies to mate/be mated from current position) to
// "plies to mate/be mated (TB win/loss) from the root". However, to avoid
// potentially false mate or TB scores related to the 50 moves rule and the
// graph history interaction, we return the highest non-TB score instead.
Value value_from_tt(Value v, int ply, int r50c) {

    if (!is_valid(v))
        return VALUE_NONE;

    // handle TB win or better
    if (is_win(v))
    {
        // Downgrade a potentially false mate score
        if (v >= VALUE_MATE_IN_MAX_PLY && VALUE_MATE - v > 100 - r50c)
            return VALUE_TB_WIN_IN_MAX_PLY - 1;

        // Downgrade a potentially false TB score.
        if (VALUE_TB - v > 100 - r50c)
            return VALUE_TB_WIN_IN_MAX_PLY - 1;

        return v - ply;
    }

    // handle TB loss or worse
    if (is_loss(v))
    {
        // Downgrade a potentially false mate score.
        if (v <= VALUE_MATED_IN_MAX_PLY && VALUE_MATE + v > 100 - r50c)
            return VALUE_TB_LOSS_IN_MAX_PLY + 1;

        // Downgrade a potentially false TB score.
        if (VALUE_TB + v > 100 - r50c)
            return VALUE_TB_LOSS_IN_MAX_PLY + 1;

        return v + ply;
    }

    return v;
}


// Adds current move and appends child pv[]
void update_pv(Move* pv, Move move, const Move* childPv) {

    for (*pv++ = move; childPv && *childPv != Move::none();)
        *pv++ = *childPv++;
    *pv = Move::none();
}


// Updates stats at the end of search() when a bestMove is found
void update_all_stats(const Position&      pos,
                      Stack*               ss,
                      Search::Worker&      workerThread,
                      Move                 bestMove,
                      Square               prevSq,
                      ValueList<Move, 32>& quietsSearched,
                      ValueList<Move, 32>& capturesSearched,
                      Depth                depth,
                      bool                 isTTMove,
                      int                  moveCount) {

    CapturePieceToHistory& captureHistory = workerThread.captureHistory;
    Piece                  moved_piece    = pos.moved_piece(bestMove);
    PieceType              captured;

    int bonus = std::min(162 * depth - 92, 1587) + 298 * isTTMove;
    int malus = std::min(694 * depth - 230, 2503) - 32 * (moveCount - 1);

    if (!pos.capture_stage(bestMove))
    {
        update_quiet_histories(pos, ss, workerThread, bestMove, bonus * 1202 / 1024);

        // Decrease stats for all non-best quiet moves
        for (Move move : quietsSearched)
            update_quiet_histories(pos, ss, workerThread, move, -malus * 1152 / 1024);
    }
    else
    {
        // Increase stats for the best move in case it was a capture move
        captured = type_of(pos.piece_on(bestMove.to_sq()));
        captureHistory[moved_piece][bestMove.to_sq()][captured] << bonus * 1236 / 1024;
    }

    // Extra penalty for a quiet early move that was not a TT move in
    // previous ply when it gets refuted.
    if (prevSq != SQ_NONE && ((ss - 1)->moveCount == 1 + (ss - 1)->ttHit) && !pos.captured_piece())
        update_continuation_histories(ss - 1, pos.piece_on(prevSq), prevSq, -malus * 976 / 1024);

    // Decrease stats for all non-best capture moves
    for (Move move : capturesSearched)
    {
        moved_piece = pos.moved_piece(move);
        captured    = type_of(pos.piece_on(move.to_sq()));
        captureHistory[moved_piece][move.to_sq()][captured] << -malus * 1224 / 1024;
    }
}


// Updates histories of the move pairs formed by moves
// at ply -1, -2, -3, -4, and -6 with current move.
void update_continuation_histories(Stack* ss, Piece pc, Square to, int bonus) {
    static constexpr std::array<ConthistBonus, 6> conthist_bonuses = {
      {{1, 1029}, {2, 656}, {3, 326}, {4, 536}, {5, 120}, {6, 537}}};

    for (const auto [i, weight] : conthist_bonuses)
    {
        // Only update the first 2 continuation histories if we are in check
        if (ss->inCheck && i > 2)
            break;
        if (((ss - i)->currentMove).is_ok())
            (*(ss - i)->continuationHistory)[pc][to] << bonus * weight / 1024;
    }
}

// Updates move sorting heuristics

void update_quiet_histories(
  const Position& pos, Stack* ss, Search::Worker& workerThread, Move move, int bonus) {

    Color us = pos.side_to_move();
    workerThread.mainHistory[us][move.from_to()] << bonus;  // Untuned to prevent duplicate effort

    if (ss->ply < LOW_PLY_HISTORY_SIZE)
        workerThread.lowPlyHistory[ss->ply][move.from_to()] << bonus * 844 / 1024;

    update_continuation_histories(ss, pos.moved_piece(move), move.to_sq(), bonus * 964 / 1024);

    int pIndex = pawn_structure_index(pos);
    workerThread.pawnHistory[pIndex][pos.moved_piece(move)][move.to_sq()] << bonus * 615 / 1024;
}

}

// When playing with strength handicap, choose the best move among a set of
// RootMoves using a statistical rule dependent on 'level'. Idea by Heinz van Saanen.
Move Skill::pick_best(const RootMoves& rootMoves, size_t multiPV) {
    static PRNG rng(now());  // PRNG sequence should be non-deterministic

    // RootMoves are already sorted by score in descending order
    Value  topScore = rootMoves[0].score;
    int    delta    = std::min(topScore - rootMoves[multiPV - 1].score, int(PawnValue));
    int    maxScore = -VALUE_INFINITE;
    double weakness = 120 - 2 * level;

    // Choose best move. For each move score we add two terms, both dependent on
    // weakness. One is deterministic and bigger for weaker levels, and one is
    // random. Then we choose the move with the resulting highest score.
    for (size_t i = 0; i < multiPV; ++i)
    {
        // This is our magic formula
        int push = (weakness * int(topScore - rootMoves[i].score)
                    + delta * (rng.rand<unsigned>() % int(weakness)))
                 / 128;

        if (rootMoves[i].score + push >= maxScore)
        {
            maxScore = rootMoves[i].score + push;
            best     = rootMoves[i].pv[0];
        }
    }

    return best;
}


// Used to print debug info and, more importantly, to detect
// when we are out of available time and thus stop the search.
void SearchManager::check_time(Search::Worker& worker) {
    if (--callsCnt > 0)
        return;

    // When using nodes, ensure checking rate is not lower than 0.1% of nodes
    callsCnt = worker.limits.nodes ? std::min(512, int(worker.limits.nodes / 1024)) : 512;

    static TimePoint lastInfoTime = now();

    TimePoint elapsed = tm.elapsed([&worker]() { return worker.threads.nodes_searched(); });
    TimePoint tick    = worker.limits.startTime + elapsed;

    if (tick - lastInfoTime >= 1000)
    {
        lastInfoTime = tick;
        dbg_print();
    }

    // We should not stop pondering until told so by the GUI
    if (ponder)
        return;

    if (
      // Later we rely on the fact that we can at least use the mainthread previous
      // root-search score and PV in a multithreaded environment to prove mated-in scores.
      worker.completedDepth >= 1
      && ((worker.limits.use_time_management() && (elapsed > tm.maximum() || stopOnPonderhit))
          || (worker.limits.movetime && elapsed >= worker.limits.movetime)
          || (worker.limits.nodes && worker.threads.nodes_searched() >= worker.limits.nodes)))
        worker.threads.stop = worker.threads.abortedSearch = true;
}

// Used to correct and extend PVs for moves that have a TB (but not a mate) score.
// Keeps the search based PV for as long as it is verified to maintain the game
// outcome, truncates afterwards. Finally, extends to mate the PV, providing a
// possible continuation (but not a proven mating line).
void syzygy_extend_pv(const OptionsMap&         options,
                      const Search::LimitsType& limits,
                      Position&                 pos,
                      RootMove&                 rootMove,
                      Value&                    v) {

    auto t_start      = std::chrono::steady_clock::now();
    int  moveOverhead = int(options["Move Overhead"]);
    bool rule50       = bool(options["Syzygy50MoveRule"]);

    // Do not use more than moveOverhead / 2 time, if time management is active
    auto time_abort = [&t_start, &moveOverhead, &limits]() -> bool {
        auto t_end = std::chrono::steady_clock::now();
        return limits.use_time_management()
            && 2 * std::chrono::duration<double, std::milli>(t_end - t_start).count()
                 > moveOverhead;
    };

    std::list<StateInfo> sts;

    // Step 0, do the rootMove, no correction allowed, as needed for MultiPV in TB.
    auto& stRoot = sts.emplace_back();
    pos.do_move(rootMove.pv[0], stRoot);
    int ply = 1;

    // Step 1, walk the PV to the last position in TB with correct decisive score
    while (size_t(ply) < rootMove.pv.size())
    {
        Move& pvMove = rootMove.pv[ply];

        RootMoves legalMoves;
        for (const auto& m : MoveList<LEGAL>(pos))
            legalMoves.emplace_back(m);

        Tablebases::Config config = Tablebases::rank_root_moves(options, pos, legalMoves);
        RootMove&          rm     = *std::find(legalMoves.begin(), legalMoves.end(), pvMove);

        if (legalMoves[0].tbRank != rm.tbRank)
            break;

        ply++;

        auto& st = sts.emplace_back();
        pos.do_move(pvMove, st);

        // Do not allow for repetitions or drawing moves along the PV in TB regime
        if (config.rootInTB && ((rule50 && pos.is_draw(ply)) || pos.is_repetition(ply)))
        {
            pos.undo_move(pvMove);
            ply--;
            break;
        }

        // Full PV shown will thus be validated and end in TB.
        // If we cannot validate the full PV in time, we do not show it.
        if (config.rootInTB && time_abort())
            break;
    }

    // Resize the PV to the correct part
    rootMove.pv.resize(ply);

    // Step 2, now extend the PV to mate, as if the user explored syzygy-tables.info
    // using top ranked moves (minimal DTZ), which gives optimal mates only for simple
    // endgames e.g. KRvK.
    while (!(rule50 && pos.is_draw(0)))
    {
        if (time_abort())
            break;

        RootMoves legalMoves;
        for (const auto& m : MoveList<LEGAL>(pos))
        {
            auto&     rm = legalMoves.emplace_back(m);
            StateInfo tmpSI;
            pos.do_move(m, tmpSI);
            // Give a score of each move to break DTZ ties restricting opponent mobility,
            // but not giving the opponent a capture.
            for (const auto& mOpp : MoveList<LEGAL>(pos))
                rm.tbRank -= pos.capture(mOpp) ? 100 : 1;
            pos.undo_move(m);
        }

        // Mate found
        if (legalMoves.size() == 0)
            break;

        // Sort moves according to their above assigned rank.
        // This will break ties for moves with equal DTZ in rank_root_moves.
        std::stable_sort(
          legalMoves.begin(), legalMoves.end(),
          [](const Search::RootMove& a, const Search::RootMove& b) { return a.tbRank > b.tbRank; });

        // The winning side tries to minimize DTZ, the losing side maximizes it
        Tablebases::Config config = Tablebases::rank_root_moves(options, pos, legalMoves, true);

        // If DTZ is not available we might not find a mate, so we bail out
        if (!config.rootInTB || config.cardinality > 0)
            break;

        ply++;

        Move& pvMove = legalMoves[0].pv[0];
        rootMove.pv.push_back(pvMove);
        auto& st = sts.emplace_back();
        pos.do_move(pvMove, st);
    }

    // Finding a draw in this function is an exceptional case, that cannot happen when rule50 is false or
    // during engine game play, since we have a winning score, and play correctly
    // with TB support. However, it can be that a position is draw due to the 50 move
    // rule if it has been been reached on the board with a non-optimal 50 move counter
    // (e.g. 8/8/6k1/3B4/3K4/4N3/8/8 w - - 54 106 ) which TB with dtz counter rounding
    // cannot always correctly rank. See also
    // https://github.com/official-stockfish/Stockfish/issues/5175#issuecomment-2058893495
    // We adjust the score to match the found PV. Note that a TB loss score can be
    // displayed if the engine did not find a drawing move yet, but eventually search
    // will figure it out (e.g. 1kq5/q2r4/5K2/8/8/8/8/7Q w - - 96 1 )
    if (pos.is_draw(0))
        v = VALUE_DRAW;

    // Undo the PV moves
    for (auto it = rootMove.pv.rbegin(); it != rootMove.pv.rend(); ++it)
        pos.undo_move(*it);

    // Inform if we couldn't get a full extension in time
    if (time_abort())
        sync_cout
          << "info string Syzygy based PV extension requires more time, increase Move Overhead as needed."
          << sync_endl;
}

void SearchManager::pv(Search::Worker&           worker,
                       const ThreadPool&         threads,
                       const TranspositionTable& tt,
                       Depth                     depth) {

    const auto nodes     = threads.nodes_searched();
    auto&      rootMoves = worker.rootMoves;
    auto&      pos       = worker.rootPos;
    size_t     pvIdx     = worker.pvIdx;
    size_t     multiPV   = std::min(size_t(worker.options["MultiPV"]), rootMoves.size());
    uint64_t   tbHits    = threads.tb_hits() + (worker.tbConfig.rootInTB ? rootMoves.size() : 0);

    for (size_t i = 0; i < multiPV; ++i)
    {
        bool updated = rootMoves[i].score != -VALUE_INFINITE;

        if (depth == 1 && !updated && i > 0)
            continue;

        Depth d = updated ? depth : std::max(1, depth - 1);
        Value v = updated ? rootMoves[i].uciScore : rootMoves[i].previousScore;

        if (v == -VALUE_INFINITE)
            v = VALUE_ZERO;

        bool tb = worker.tbConfig.rootInTB && std::abs(v) <= VALUE_TB;
        v       = tb ? rootMoves[i].tbScore : v;

        bool isExact = i != pvIdx || tb || !updated;  // tablebase- and previous-scores are exact

        // Potentially correct and extend the PV, and in exceptional cases v
        if (is_decisive(v) && std::abs(v) < VALUE_MATE_IN_MAX_PLY
            && ((!rootMoves[i].scoreLowerbound && !rootMoves[i].scoreUpperbound) || isExact))
            syzygy_extend_pv(worker.options, worker.limits, pos, rootMoves[i], v);

        std::string pv;
        for (Move m : rootMoves[i].pv)
            pv += UCIEngine::move(m, pos.is_chess960()) + " ";

        // Remove last whitespace
        if (!pv.empty())
            pv.pop_back();

        auto wdl   = worker.options["UCI_ShowWDL"] ? UCIEngine::wdl(v, pos) : "";
        auto bound = rootMoves[i].scoreLowerbound
                     ? "lowerbound"
                     : (rootMoves[i].scoreUpperbound ? "upperbound" : "");

        InfoFull info;

        info.depth    = d;
        info.selDepth = rootMoves[i].selDepth;
        info.multiPV  = i + 1;
        info.score    = {v, pos};
        info.wdl      = wdl;

        if (!isExact)
            info.bound = bound;

        TimePoint time = std::max(TimePoint(1), tm.elapsed_time());
        info.timeMs    = time;
        info.nodes     = nodes;
        info.nps       = nodes * 1000 / time;
        info.tbHits    = tbHits;
        info.pv        = pv;
        info.hashfull  = tt.hashfull();

        updates.onUpdateFull(info);
    }
}

// Called in case we have no ponder move before exiting the search,
// for instance, in case we stop the search during a fail high at root.
// We try hard to have a ponder move to return to the GUI,
// otherwise in case of 'ponder on' we have nothing to think about.
bool RootMove::extract_ponder_from_tt(const TranspositionTable& tt, Position& pos) {

    StateInfo st;
    ASSERT_ALIGNED(&st, Eval::NNUE::CacheLineSize);

    assert(pv.size() == 1);
    if (pv[0] == Move::none())
        return false;

    pos.do_move(pv[0], st, &tt);

    auto [ttHit, ttData, ttWriter] = tt.probe(pos.key());
    if (ttHit)
    {
        if (MoveList<LEGAL>(pos).contains(ttData.move))
            pv.push_back(ttData.move);
    }

    pos.undo_move(pv[0]);
    return pv.size() > 1;
}


}  // namespace Stockfish
