/*
  Stockfish, a UCI chess playing engine derived from Glaurung 2.1
  Copyright (C) 2004-2025 The Stockfish developers (see AUTHORS file)

  Stockfish is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  Stockfish is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "search.h"

#include <algorithm>
#include <array>
#include <atomic>
#include <cassert>
#include <chrono>
#include <cmath>
#include <cstdint>
#include <cstdlib>
#include <initializer_list>
#include <iostream>
#include <list>
#include <ratio>
#include <string>
#include <utility>

#include "evaluate.h"
#include "history.h"
#include "misc.h"
#include "movegen.h"
#include "movepick.h"
#include "nnue/network.h"
#include "nnue/nnue_accumulator.h"
#include "nnue/nnue_common.h"
#include "position.h"
#include "syzygy/tbprobe.h"
#include "thread.h"
#include "timeman.h"
#include "tt.h"
#include "uci.h"
#include "ucioption.h"

namespace Stockfish {

int savedCaptureHistory[16*64*8] = {
    -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -1951, 820, 3075, 6431, 10271, -655, -655, -655, 3197, 10514, 10640, 10040, 10690, -655, -655, -655, 760, 9585, 5784, 7642, 10692, -655, -655, -655, -1340, 9964, 7498, 7911, 9920, -655, -655, -655, 337, 10608, 7463, 7803, 9638, -655, -655, -655, -7864, 4245, 6366, 4212, 10510, -655, -655, -655, 1232, 9843, 2089, 8984, 9544, -655, -655, -655, -7826, 10558, 10692, 1006, 9604, -655, -655, -655, -591, 5847, 76, 8759, 5536, -655, -655, -655, 5580, 10339, 10531, 10515, 7440, -655, -655, -655, -2061, 10690, 10246, 8486, 10306, -655, -655, -655, 8000, 4349, 10444, 10692, 10664, -655, -655, -655, 10521, 10692, 10026, 10692, 10692, -655, -655, -655, 3223, 6593, 8477, 6576, 10633, -655, -655, -655, 10289, 9010, 9990, -782, 10673, -655, -655, -655, -6966, -2192, 3196, 10398, 10290, -655, -655, -655, -2277, 7733, 7884, 10091, 10617, -655, -655, -655, 2541, -2579, 362, 9463, 10667, -655, -655, -655, 6006, 10628, 10564, 10692, 10679, -655, -655, -655, -4735, 8196, 7172, 9556, 10688, -655, -655, -655, 7534, 10691, 10674, 10692, 10692, -655, -655, -655, 6879, 10650, 10633, 7857, 10692, -655, -655, -655, 911, 7439, 10370, 10505, 10692, -655, -655, -655, -2141, 9291, 7421, 1367, 5429, -655, -655, -541, -6538, 10427, 9463, 5140, -710, -655, -655, 3329, -2432, 10569, 9360, 9038, 10657, -655, -655, -2347, 8048, 5380, 10230, 10261, 10692, -655, -655, -1569, 6115, 10275, 8373, 8192, 10692, -655, -655, 4472, 9587, 2996, 8048, 1864, 7566, -655, -655, -56, -3307, 3105, 10692, 9546, 10691, -655, -655, 2924, 4482, 9661, 8076, -655, 10083, -655, -655, 288, 681, 5260, -655, 1162, -655, -655, -655, -655, 941, -655, -655, 6723, -655, -655, -655, -655, 9003, -655, 825, 6818, 3539, -655, -655, -655, 4621, 7054, 6199, 5310, 9800, -655, -655, -655, 6975, 10605, 10683, 1229, 10692, -655, -655, -655, -4899, 8894, -938, 885, 10692, -655, -655, -655, 9801, 990, -655, 9325, 640, -655, -655, -655, 4510, -1918, 9256, 8641, -655, -655, -655, -655, -7096, -655, -655, 2326, -655, -655, -655, -655, -655, -655, -655, 3216, 919, -655, -655, -2621, -655, -6486, -655, 5550, -358, -655, -655, -7494, -655, -655, -2584, -184, 267, -655, -655, -823, -655, -655, -655, 8545, 10692, -655, -655, -938, -655, -655, 2452, 1308, -655, -655, -655, -3679, -655, -655, 2861, 10038, -655, -655, -655, -3210, -655, -3668, -655, -655, -655, -655, -655, -655, -655, -655, -655, 9125, -655, -655, -655, -655, -655, 8801, 3537, 5388, 8748, -655, -655, -655, -655, -655, -4222, 2631, 10692, -655, -655, -655, -655, 682, 185, 0, -1704, -655, -655, -655, -655, -1325, -7029, 9268, 3027, -655, -655, -655, -655, -3063, -846, 7683, 2504, -655, -655, -655, -655, -2245, -351, 9917, 10692, -655, -655, -655, -655, -655, -478, 2502, 10692, -655, -655, -655, -655, -655, -566, -655, 8444, -655, -655, -655, -5570, 10521, 4455, 7458, 10692, -655, -655, -655, -5397, 2191, 10520, 10618, 4767, -655, -655, -655, -1271, 9784, 2273, 5432, 10684, -655, -655, -655, 4736, -1377, 778, 8073, 10692, -655, -655, -655, 2652, 4484, 9681, 10175, 5797, -655, -655, -655, -2180, 9109, 10607, 964, 10692, -655, -655, -655, 871, -17, 8098, 1229, 10681, -655, -655, -655, -1024, 10619, 9263, -184, 10692, -655, -655, -655, -1729, 6788, 10028, 8935, 10681, -655, -655, -655, -1348, 6903, 3247, 1646, 9623, -655, -655, -655, -1271, 10692, 10623, -702, 10692, -655, -655, -655, 4810, 6697, 8294, 636, 10692, -655, -655, -655, -5428, 7985, 8633, 2176, 10653, -655, -655, -655, 5686, 9707, 10059, 8591, 10621, -655, -655, -655, 9187, 5626, 8747, 4567, -655, -655, -655, -655, 3154, -1437, 10692, -655, 85, -655, -655, -655, -5361, 191, 9617, 8497, 7815, -655, -655, -655, -9194, 5137, 10692, 7557, 10692, -655, -655, -655, 2889, 7626, 7721, 7370, 6921, -655, -655, -655, 1613, 6560, 9773, 8171, 10692, -655, -655, -655, 7300, 10692, 2383, 10106, 10665, -655, -655, -655, 8377, 10691, 10692, 4482, 10359, -655, -655, -655, 5263, 7491, 9590, 2052, 10207, -655, -655, -655, -4078, 6499, 10073, 5732, 10591, -655, -655, -655, -2351, 10203, 9232, 10654, 10625, -655, -655, -655, -1599, 10661, 10250, 5327, 10692, -655, -655, -655, -8569, 2583, 10692, 8625, 10692, -655, -655, -655, -3263, 3497, 8249, 10692, 10692, -655, -655, -655, 3150, 4264, 6841, 8644, 10692, -655, -655, -655, 8130, 7008, 8697, -137, 10590, -655, -655, -655, 7383, 8939, 8366, 9960, 10682, -655, -655, -655, -2950, 8523, 8720, -80, 10585, -655, -655, -655, -9434, 1808, -1535, 9350, 4097, -655, -655, -655, -9490, -835, 8507, 1514, 10692, -655, -655, -655, -1352, -7816, -2811, 8982, 10689, -655, -655, -655, -2129, 4609, 6612, 8581, 10692, -655, -655, -655, 2456, -2360, 1615, 5396, 10692, -655, -655, -655, -6888, 3565, 10374, 3395, 10692, -655, -655, -655, 6470, 7819, 1860, 1146, 9279, -655, -655, -655, -4707, -555, 106, -655, 5779, -655, -655, -655, -7058, -848, 4436, 5597, 2733, -655, -655, -655, 5105, -655, 10649, 8570, 8054, -655, -655, -655, -363, 10671, 8813, 8587, 10692, -655, -655, -655, -9119, 194, 3014, 10061, 10632, -655, -655, -655, -2093, -6901, -6464, 2990, 10692, -655, -655, -655, 3690, 7871, -2728, 10679, 9495, -655, -655, -655, -799, 589, 221, 8491, 5608, -655, -655, -655, 2296, 8505, -655, 3782, 1700, -655, -655, -655, -655, -655, 3337, 4158, 6766, -655, -655, -655, -655, 5913, -655, 3496, 1854, -655, -655, -655, -655, -5441, 1745, 8211, 9660, -655, -655, -655, -655, -655, 8434, 9667, 10626, -655, -655, -655, -655, -5185, -2522, 9879, 8772, -655, -655, -655, -655, 4061, -7044, 6715, 1544, -655, -655, -655, -655, -5336, -655, 5176, -655, -655, -655, -655, -655, -655, 317, 8663, -655, -655, -655, -655, -655, -655, 5057, 8651, 9541, -655, -655, -655, -655, 489, -478, 4909, 939, -655, -655, -655, -655, 1786, -3623, 5140, 4942, -655, -655, -655, -655, -6232, 5869, 6931, 3373, -655, -655, -655, -655, -2625, -655, 4258, 10350, -655, -655, -655, -655, -4278, -4386, 10453, 10608, -655, -655, -655, -655, -566, -655, -655, 1037, -655, -655, -655, -655, 1539, 8889, 8802, 10692, -655, -655, -655, 4340, 8751, 2619, 460, 4243, -655, -655, -655, 10600, 10447, 10677, 10692, 10692, -655, -655, -655, -81, 10692, 9303, 9852, 10671, -655, -655, -655, 10279, 8628, 9910, 9789, 10689, -655, -655, -655, 10022, 9575, 6918, 7822, 10692, -655, -655, -655, 7674, 4723, 4741, 8176, 10692, -655, -655, -655, 8174, 10692, 7814, 3369, 10692, -655, -655, -655, -358, 10562, 4290, 6838, 9201, -655, -655, -655, -5742, 6595, 10692, 9938, 10692, -655, -655, -655, 5155, 6157, 3137, 2912, 10652, -655, -655, -655, 9995, 5232, 10692, 8290, 10690, -655, -655, -655, 6578, 8260, 10219, 8882, 10647, -655, -655, -655, 6972, 8419, 10219, 7019, 10692, -655, -655, -655, 10559, 10628, 10692, 6751, 10612, -655, -655, -655, -404, 9477, 7968, -6869, 4959, -655, -655, -655, -2941, 5631, 10692, -655, 8457, -655, -655, -655, 9601, -7508, 2819, 5999, 10201, -655, -655, -655, 6204, 89, -6171, 2345, 10692, -655, -655, -655, -1467, 6934, 6784, 10368, 10692, -655, -655, -655, 4453, 8750, 9319, 9506, 10219, -655, -655, -655, 7836, 5767, 10692, 3810, 10692, -655, -655, -655, 2900, 10292, 9273, 6034, 8965, -655, -655, -655, 9320, 4035, 4047, 10648, 10272, -655, -655, -655, -2676, 8220, 3519, 9017, 10428, -655, -655, -655, 6338, 8286, 477, 10336, 10692, -655, -655, -655, 3803, 9582, 5266, 9497, 10692, -655, -655, -655, -4553, 3492, -1689, 4810, 10541, -655, -655, -655, -348, 9388, 5806, 9192, 10692, -655, -655, -655, 5151, 10158, 9682, 9852, 10646, -655, -655, -655, 5995, 5496, 4623, 2230, 5291, -655, -655, -655, 7365, 4943, -1182, 6303, 10692, -655, -655, -655, 6961, 6795, 8842, 1989, 10004, -655, -655, -655, -10587, 9890, 10596, 10626, 10692, -655, -655, -655, -6668, -4915, 4365, 1048, 10692, -655, -655, -655, -1437, 2963, 9852, 6442, 4625, -655, -655, -655, -5322, -6822, -4195, 7660, 10692, -655, -655, -655, -7493, 4972, 6229, 8646, 5017, -655, -655, -655, 4911, -8382, 525, -334, 10692, -655, -655, -655, -3210, 5945, -4696, 4636, 9472, -655, -655, -655, -10592, -2664, 1745, -2266, 8204, -655, -655, -655, -10559, 2725, 8088, 5673, 2606, -655, -655, -655, -5679, 3343, 1485, 3079, 10692, -655, -655, -655, 5459, 10677, 7961, 3517, 10692, -655, -655, -655, 7244, -5887, 4358, 2731, 10692, -655, -655, -655, -9880, -4463, 8437, 2046, 10692, -655, -655, -655, -2281, 9157, 10604, 9402, 10692, -655, -655, -655, -3274, -6444, 3452, 8665, 10524, -655, -655, -655, -10173, 488, 10373, 8888, 885, -655, -655, -655, -655, -655, 2060, 2160, 10680, -655, -655, -655, -655, -10229, -6951, 9975, 3800, -655, -655, -655, -655, 4553, 23, 4137, 10083, -655, -655, -655, -655, -5285, 7759, 7674, 10671, -655, -655, -655, -655, -5210, 2300, 10229, 10533, -655, -655, -655, -655, -7110, -4017, 3100, 9246, -655, -655, -655, -655, -6191, -566, 2527, -358, -655, -655, -655, -655, -655, 2273, 67, 3529, -655, -655, -655, -655, 786, 561, 10676, 4068, -655, -655, -655, -655, 2353, 10670, 6709, -451, -655, -655, -655, -655, 8831, 3208, 8989, 9828, -655, -655, -655, -655, -3580, -3027, 10692, 10671, -655, -655, -655, -655, 318, 1208, 10692, 10692, -655, -655, -655, -655, -715, 9228, 10692, 10692, -655, -655, -655, -655, 2979, 5130, 9465, 10624, -655, -655, -655, -655, 1629, -655, 2135, -2077, -655, -655, -655, -5799, 7107, 7692, 10682, 10692, -655, -655, -655, 99, 8153, 2826, 7603, 9575, -655, -655, -655, 1265, 9837, 5178, -2554, 8101, -655, -655, -655, 553, 602, 366, 8986, 10607, -655, -655, -655, -566, 8239, -1479, 7148, 10222, -655, -655, -655, 10185, 5613, 10692, 10643, 10692, -655, -655, -655, 7962, 1502, 3817, -165, 10179, -655, -655, -655, -3452, 8886, 2554, 8335, 10692, -655, -655, -655, -3857, 1290, 10473, 10401, 9885, -655, -655, -655, 3847, 4483, -4323, -272, 6183, -655, -655, -655, 197, 2324, 7706, 487, 8002, -655, -655, -655, 1225, 8063, 1925, 2176, 4037, -655, -655, -655, 9146, 9847, 10108, 9323, 9485, -655, -655, -655, -2541, 8866, 6003, 8202, 10150, -655, -655, -655, -655, 696, 3226, 1236, 6994, -655, -655, -655, 6414, -655, 9899, -655, 730, -655, -655, -655, -3934, -986, 10072, 9899, 10692, -655, -655, -655, -7220, -496, -2439, 6520, 10692, -655, -655, -655, -1191, 6551, 9307, 8561, 8338, -655, -655, -655, 3631, 5836, -340, 5951, 7052, -655, -655, -655, 7076, -4727, 6746, 4737, 4916, -655, -655, -655, -6527, 4200, -2633, -3297, 10302, -655, -655, -655, 9173, 1519, 1027, -655, 7405, -655, -655, -655, 4408, 4684, -1332, 10131, 10692, -655, -655, -655, -817, 5335, 9418, 10650, 9678, -655, -655, -655, -4731, 4394, 10160, 1785, 10486, -655, -655, -655, -852, -3241, 9208, 6823, 10692, -655, -655, -655, 784, -3496, 1049, 8068, 8073, -655, -655, -655, 2512, 5506, 1942, 9603, 10658, -655, -655, -655, -2618, 433, -2764, 536, 10441, -655, -655, -655, 428, -4032, 2281, -655, 10692, -655, -655, -655, 8233, 7504, 8114, -566, 1998, -655, -655, -655, -10585, -1110, 7021, 10582, 8983, -655, -655, -655, -9537, 2805, -5850, 10423, 10294, -655, -655, -655, -3419, -869, -459, 10276, 10681, -655, -655, -655, 7749, 3189, -1133, 4560, 7521, -655, -655, -655, 5995, -755, -5167, 3672, 10692, -655, -655, -655, -139, -7777, 859, -3419, 10579, -655, -655, -655, 63, -7763, -6313, -655, 6498, -655, -655, -655, -5519, -5374, 8090, 7704, 8170, -655, -655, -655, -8561, 2665, -642, 8732, 9791, -655, -655, -655, 2280, 682, 55, 8054, 10321, -655, -655, -655, 6974, 8608, -2895, 7091, 10692, -655, -655, -655, -8042, -8302, -4979, 4632, 10692, -655, -655, -655, -735, -2272, -8539, 1358, 10463, -655, -655, -655, -1553, 2960, 945, 2887, 4517, -655, -655, -655, -3253, 3854, 912, -2991, -655, -655, -655, -655, -2013, -655, -655, 4235, -655, -655, -655, -655, -655, -655, 539, 10344, 10428, -655, -655, -655, -655, 1668, -655, 6206, 1927, -655, -655, -655, -655, -1557, -955, -3449, 10574, -655, -655, -655, -655, -557, -5834, -908, 10566, -655, -655, -655, -655, -1627, -222, 6545, 10139, -655, -655, -655, -655, 2967, -5705, 2015, 9177, -655, -655, -655, -655, -3213, -655, 9851, -655, -655, -655, -655, -655, -655, 2351, 10486, -655, -655, -655, -655, -655, -4366, 9860, 10404, 10687, -655, -655, -655, -655, -2796, 1517, 7085, 10615, -655, -655, -655, -655, 2717, 9759, 6283, 10692, -655, -655, -655, -655, -1691, -2507, 9476, 10692, -655, -655, -655, -655, 6141, 7784, 10692, 10692, -655, -655, -655, -655, -10140, 579, 9829, 10692, -655, -655, -655, -655, -655, 1270, -655, 6784, -655, -655, -655, -655, 3025, 2348, 1520, 10451, -655, -655, -655, -3356, 7549, 7556, 4989, 9350, -655, -655, -655, -2659, 10151, 8744, 10262, 8344, -655, -655, -655, 9283, 10463, 10638, 10692, 7229, -655, -655, -655, 7012, -2581, 10584, 7466, 10692, -655, -655, -655, 10643, 10689, 10692, 10692, 10692, -655, -655, -655, 8351, 2778, 8165, 1921, 10692, -655, -655, -655, -1400, 4039, 10205, 7882, 10692, -655, -655, -655, -3356, -655, 10365, -655, 10692, -655, -655, -655, -4317, -3254, 9653, 5042, 4341, -655, -655, -655, 5497, 9505, 4967, 7107, 2712, -655, -655, -655, -3500, 10096, 7903, 5995, 10189, -655, -655, -655, 7788, 10683, 9909, 3215, 10472, -655, -655, -655, -4745, 7471, 10361, 9920, 10692, -655, -655, -655, 1903, 8002, 10692, 5817, 10692, -655, -655, -655, -1733, 10069, -444, 4162, 4726, -655, -655, -655, -655, -3364, 8848, -358, 124, -655, -655, -655, 1566, 7769, 10692, 10623, 10692, -655, -655, -655, -3587, 6532, 8648, 9552, 6529, -655, -655, -655, -353, 8931, 10040, 9490, 10345, -655, -655, -655, -141, 8652, 10692, 8332, 8367, -655, -655, -655, 10662, 6223, 9865, 9921, 10674, -655, -655, -655, 982, 7271, 9577, 6246, 10135, -655, -655, -655, 1428, 9217, 10673, 7080, 3465, -655, -655, -655, -6187, 6645, -5197, 4589, 10083, -655, -655, -655, 3323, 1595, 10624, 5380, 10130, -655, -655, -655, -3674, 859, 10638, 8460, 3902, -655, -655, -655, 5469, 8572, 9966, 1138, 6381, -655, -655, -655, 5498, 10454, -2599, 5664, 1355, -655, -655, -655, 10206, 9637, 9314, 9599, 10208, -655, -655, -655, 388, 4962, 10546, 4249, 2004, -655, -655, -655, -1312, 6659, 2077, 10499, 4874, -655, -655, -655, 852, 9552, 5568, 10331, 10127, -655, -655, -655, -5096, 162, 10692, 10647, 2524, -655, -655, -655, -2474, -7935, -1169, 3383, 191, -655, -655, -655, 4682, -446, 9957, 10196, 1559, -655, -655, -655, 8600, 1186, 2678, 7330, 7393, -655, -655, -655, -670, -3545, 10685, 6543, 8302, -655, -655, -655, 9989, 2537, 9039, -51, -4622, -655, -655, -655, 82, -6321, 116, -2720, -559, -655, -655, -655, 580, -984, 10692, 10692, 8650, -655, -655, -655, 2733, 8374, 2605, 10692, 5052, -655, -655, -655, 171, 4585, 6966, 3572, -3841, -655, -655, -655, -3120, 4833, 9229, 10393, 2307, -655, -655, -655, 2975, 1592, 3531, 3775, 1917, -655, -655, -655, 3156, 6631, 2675, 5174, 6829, -655, -655, -655, 9437, 1151, -2917, 5961, 7978, -655, -655, -655, 4776, 9167, 10692, 10140, -4125, -655, -655, -655, 7311, 10210, -655, 9215, -3140, -655, -655, -655, -655, 9364, 8818, 5847, 1559, -655, -655, -655, -655, 6680, -655, 7464, 6042, -655, -655, -655, -655, -655, 10133, 7792, 4747, -655, -655, -655, -655, -655, 2400, 7607, 7021, -655, -655, -655, -655, 10409, 1936, 10500, 9379, -655, -655, -655, -655, -655, 2892, -4032, -4837, -655, -655, -655, -655, 8427, -655, 10692, -4560, -655, -655, -655, -655, -655, -655, 10692, -358, -655, -655, -655, -655, -655, -655, 3142, -655, -655, -655, -655, -655, -655, -655, 8440, 10085, -655, -655, -655, -655, -1693, -79, 7425, 3582, -655, -655, -655, -655, 9231, 5535, 10692, 10692, -655, -655, -655, -655, -165, 6099, 10667, 10692, -655, -655, -655, -655, -5586, 4622, 10412, 10692, -655, -655, -655, -655, -655, 1206, 418, 10220, -655, -655, -655, -655, 5317, 2197, 8708, 10692, -655, -655, -655, -655, 2959, 7019, 1388, -655, -655, -655, -655, 2345, 4309, 10692, 10157, 10692, -655, -655, -655, -1735, 6025, 8864, 10440, 10660, -655, -655, -655, 2335, -894, 10692, 10692, 10692, -655, -655, -655, -1333, 7725, 7468, 10692, 10692, -655, -655, -655, 10692, 10690, 10692, 6067, 10692, -655, -655, -655, -6162, 6598, 10372, 10692, 10692, -655, -655, -655, -3295, 9836, 10692, 5435, 10692, -655, -655, -655, -655, -655, 10207, -655, -655, -655, -655, -655, -655, 32, 2886, -655, -655, -655, -655, -655, 4501, 3509, 9502, 10662, 10655, -655, -655, -655, 10231, 3574, 10666, 10198, 9359, -655, -655, -655, 3388, 6125, 10692, 8739, 6759, -655, -655, -655, -1048, 7620, 3522, 1281, 10418, -655, -655, -655, -133, -304, 3242, 1250, 5527, -655, -655, -655, -655, -992, 10692, -69, 9442, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, 2385, 10650, 8920, -655, -655, -655, -655, -655, -3363, 1936, 202, -566, -358, -655, -655, -655, 5121, 5857, -99, 1838, 4894, -655, -655, -655, -2697, 4091, -566, 1158, 4438, -655, -655, -655, 4206, -428, 2386, -165, 8895, -655, -655, -655, -655, 3633, 9446, -655, 3836, -655, -655, -655, -655, -655, -655, -655, 10594, -655, -655, -655, 5094, 761, -655, -655, -655, -655, -655, -655, -66, -655, -655, -655, -655, -655, -655, -655, -218, -655, 106, -655, 23, -655, -655, -655, -1356, -655, -655, -655, -655, -655, -655, -655, -1019, -655, -655, -655, -655, -655, -655, -655, 655, -655, -478, -655, -655, -655, -655, -655, 2907, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, 222, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, 3877, -655, -655, -655, 10410, -655, -655, -655, -3899, -655, 550, 1684, 215, -478, -655, -655, 304, -655, 438, 814, 6103, 7818, -655, -655, -4772, -655, -655, -655, 10230, 10692, -655, -655, 231, -655, -655, -655, 5888, -655, -655, -655, -655, -655, -655, -6962, 10692, -655, -655, -655, -655, -655, -760, -655, -655, -655, -655, -655, -655, -655, -655, -655, 1059, -655, -655, -655, -655, 10542, 9920, 4446, 4194, -655, -655, -655, -655, 1344, -655, 10636, 7188, 2376, -655, -655, -655, -4895, 8997, 10496, 10692, 10692, -655, -655, -655, 129, 10388, 10666, 1478, 10692, -655, -655, -655, -4784, 8206, 6450, 3608, 10692, -655, -655, -655, 10317, -655, -655, 1575, 2729, -655, -655, -655, -3057, -655, 6898, 2189, -655, -655, -655, -655, -2791, -655, 714, -655, -655, -655, -655, 686, -3097, -1081, 6688, 5243, 7360, -655, -655, 2331, -1440, 4958, 3209, 10603, 10692, -655, -655, -2071, 7534, 6607, 9305, 6313, 10692, -655, -655, 1144, 7317, 6308, 1465, 4380, 10692, -655, -655, 2893, 6057, 9462, 4301, 9973, 9106, -655, -655, 3745, 5484, 4302, 7403, -1124, 10692, -655, -655, 6655, 4808, 6997, 9639, 715, 10063, -655, -655, -2455, 3997, -655, -655, -655, -655, -655, -655, -655, 1630, 1528, 6353, 10685, 10692, -655, -655, -655, 2652, 9743, 3073, 10692, 10692, -655, -655, -655, -5795, 6673, 9686, 9889, 10692, -655, -655, -655, 6243, 8473, 10304, 10692, 10692, -655, -655, -655, 7210, 9814, 10692, 10692, 6628, -655, -655, -655, -2001, 7012, 10655, 10468, 10692, -655, -655, -655, 7610, 8694, 8924, 10297, 10692, -655, -655, -655, -3267, 7481, 6656, 6883, 8562, -655, -655, -655, 345, -192, 7890, 9971, 9884, -655, -655, -655, 694, 8993, 10111, 3056, 10692, -655, -655, -655, -5487, -7, 8320, 10593, 9799, -655, -655, -655, 6851, 10449, 10260, 9742, 10692, -655, -655, -655, 6385, 7398, 8685, 10635, 10692, -655, -655, -655, -5895, 6220, -530, 8725, 10692, -655, -655, -655, 5531, 5416, 798, 9793, 10692, -655, -655, -655, -414, -963, 654, 2279, 7445, -655, -655, -655, -5784, 6202, 8302, 10503, 8864, -655, -655, -655, 749, 10647, 6957, 9795, 10653, -655, -655, -655, -1149, 10081, 10349, 10618, 10692, -655, -655, -655, 8336, 4534, 5246, 10006, 6785, -655, -655, -655, 7308, 9395, 7661, 10407, 10476, -655, -655, -655, -474, -5630, 4389, 7002, 4764, -655, -655, -655, 4320, 6154, 9005, 10692, 10692, -655, -655, -655, -3399, -1228, 7310, 9317, 10692, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -566, -478, -567, -655, -655, -655, -655, -655, -5421, 10613, 3107, 9202, -655, -655, -655, -655, -655, -5887, 4766, 8252, -655, -655, -655, -655, -3392, 2618, 7985, 8861, -655, -655, -655, -655, 1150, -566, 8119, 10692, -655, -655, -655, -655, -655, -3963, 1870, -184, -655, -655, -655, -655, 2748, -655, -655, -655, -655, -655, -655, -655, -655, -655, 7171, -655, -655, -655, -655, -5831, 2997, 10473, 8887, 10035, -655, -655, -655, 5459, -655, 6035, -184, 8600, -655, -655, -655, -5758, 5684, 9844, 5458, 10651, -655, -655, -655, -10645, 463, -1213, 8217, 9995, -655, -655, -655, 5019, -6463, -5709, 7970, 10692, -655, -655, -655, -6974, 10679, 10338, 10680, 9747, -655, -655, -655, 2815, -655, 8252, 4227, -655, -655, -655, -655, -9427, 8202, 10672, 430, 5027, -655, -655, -655, 2152, 1526, 10523, 2311, 8901, -655, -655, -655, -427, -6242, 4091, -256, 10692, -655, -655, -655, -7662, 5936, 6013, 10178, 10692, -655, -655, -655, 1089, 9952, 3367, 8136, 10683, -655, -655, -655, -5591, 7045, 10658, 10203, 10090, -655, -655, -655, 4316, 5719, 4091, 3072, 10692, -655, -655, -655, 2222, -5261, 3819, 5082, 7750, -655, -655, -655, 8970, -358, 154, -80, -655, -655, -655, -655, -9415, 4503, 7208, 1010, 10692, -655, -655, -655, -4189, 8630, 3968, 10416, 10110, -655, -655, -655, -3370, 6324, 9368, 10273, 10692, -655, -655, -655, -8092, -5903, 5058, 9208, 10692, -655, -655, -655, -1796, 7085, 2036, 10149, 10692, -655, -655, -655, -1748, 2882, 5644, 6984, 2690, -655, -655, -655, 4731, 9455, 3070, 3646, 10543, -655, -655, -655, -2537, 2182, 3835, 5176, 9493, -655, -655, -655, 1900, 10060, 10231, 10620, 10679, -655, -655, -655, -790, 8772, 4504, 10416, 10692, -655, -655, -655, -3874, 10681, 5053, 10372, 9312, -655, -655, -655, 1784, 6816, -5680, 50, 10692, -655, -655, -655, 1133, 10009, 814, 1172, 10692, -655, -655, -655, -4144, 10689, 10692, 9896, 10692, -655, -655, -655, -134, 4887, 8045, 3111, 10692, -655, -655, -655, -6192, -1995, -2784, 6949, 10692, -655, -655, -655, 1798, 330, 9916, 9186, 6962, -655, -655, -655, -3904, 6252, 1896, 4127, 10421, -655, -655, -655, 5661, 3236, 9593, 9936, 10692, -655, -655, -655, -5377, 10078, 10512, 6575, 9254, -655, -655, -655, 2636, 8509, 7031, 8476, 10600, -655, -655, -655, 8908, 10692, 10692, 9047, 10681, -655, -655, -655, 3898, 7796, 8860, 3938, 10692, -655, -655, -655, -871, 4146, 4763, 639, 7478, -655, -655, -655, -6281, 10525, 6753, 10040, 10692, -655, -655, -655, 224, 10610, 9439, 7994, 10528, -655, -655, -655, 2627, 10169, 5225, 6348, 10626, -655, -655, -655, 7305, 8030, 7724, 9404, 6189, -655, -655, -655, 2128, 6426, 7693, 10692, 2839, -655, -655, -655, 10142, 10314, 10676, 6485, 10692, -655, -655, -655, -3364, 10078, 10692, 10251, 5094, -655, -655, -655, -99, 10006, 9631, 5760, 10692, -655, -655, -655, -655, 6441, 8390, 9399, 10485, -655, -655, -655, -655, 7000, 7798, 3137, 10692, -655, -655, -655, -655, 1661, 1748, 4755, 5600, -655, -655, -655, -655, -744, -2407, 4097, 4665, -655, -655, -655, -655, 7151, 4322, 2930, 8371, -655, -655, -655, -655, 1814, -2589, 167, 10692, -655, -655, -655, -655, -655, 3606, 4999, 10692, -655, -655, -655, -655, -655, 2896, 3581, 10692, -655, -655, -655, -655, -655, -655, 7279, 7346, -655, -655, -655, -655, -7327, 5485, 4655, 9945, -655, -655, -655, -655, -655, 9054, 4918, 10041, -655, -655, -655, -655, -7908, 7153, 7809, 7032, -655, -655, -655, -655, 8757, 5497, 7977, 10692, -655, -655, -655, -655, -4739, -1243, 3592, 3788, -655, -655, -655, -655, -6934, -655, 1788, 1198, -655, -655, -655, -655, -655, 10692, 1487, -655, -655, -655, -655, -10217, -2200, 9366, 9413, 10692, -655, -655, -655, -6510, -655, 10567, 4457, 10646, -655, -655, -655, -2512, -1512, 3227, 9890, 10692, -655, -655, -655, -9427, -5131, 3526, 9636, 10692, -655, -655, -655, 1624, -1250, 3073, -5631, 10688, -655, -655, -655, -3692, 10378, 8338, 10688, 10692, -655, -655, -655, 4746, -3327, 9540, -655, 7619, -655, -655, -655, -5475, 93, 10690, 119, -655, -655, -655, -655, -10600, 9336, 3370, 4228, 10670, -655, -655, -655, -5785, -7640, 3647, 2131, 6429, -655, -655, -655, -3328, 7043, 9906, 9957, 9207, -655, -655, -655, -9455, -6258, -287, 7002, 10692, -655, -655, -655, 2948, -6510, 6164, 6287, 10669, -655, -655, -655, -52, -4474, 7917, 9098, 10692, -655, -655, -655, -1731, -3537, 2542, 245, 10676, -655, -655, -655, -5526, 16, 10692, 10640, 9416, -655, -655, -655, -7901, 4817, 1215, 9763, 4860, -655, -655, -655, 1111, 3290, 4763, 9830, 10692, -655, -655, -655, 8173, 653, -6155, 7928, 10620, -655, -655, -655, 1598, -5898, 3741, 6168, 10692, -655, -655, -655, 97, -3444, 10324, 10112, 10692, -655, -655, -655, -4940, -1696, 9674, 4485, 10498, -655, -655, -655, 5234, 10097, 3154, 10310, 7635, -655, -655, -655, -6249, 10448, 7495, 9955, 10692, -655, -655, -655, -2404, 10613, 10210, 10692, 9714, -655, -655, -655, 5839, 4725, 3580, -2461, 10447, -655, -655, -655, 8673, 10623, 9397, 10284, 9669, -655, -655, -655, -5328, -4628, 4253, 7644, 10692, -655, -655, -655, 3334, 6197, 3967, 10211, 10692, -655, -655, -655, 6718, 10553, 6782, 10692, 10279, -655, -655, -655, -7130, 416, 2410, 9551, 10676, -655, -655, -655, 5656, 6123, 4457, 7637, 4906, -655, -655, -655, -7273, 120, 5717, 10416, 10692, -655, -655, -655, 5566, 10692, 1214, -655, 10165, -655, -655, -655, 4225, 1830, 8352, 9163, 10454, -655, -655, -655, 10314, 9389, 4735, 8722, 10692, -655, -655, -655, 6132, 935, 10692, 9900, 10692, -655, -655, -655, 3406, 9990, 7354, 10357, 6342, -655, -655, -655, 5292, 10455, 4577, -655, 7313, -655, -655, -655, -6431, -5585, 10541, 4291, 10331, -655, -655, -655, -3284, 4611, -186, 4835, 9441, -655, -655, -655, 10692, 10692, 8303, 10272, 10692, -655, -655, -655, 3371, 10683, 7506, 8002, 1503, -655, -655, -655, 10620, 9289, 10108, 9530, 10692, -655, -655, -655, 7029, 7085, 10254, 10692, 10692, -655, -655, -655, 307, 9799, 10692, 5144, 10692, -655, -655, -655, 10692, 10692, 10662, 6981, 10667, -655, -655, -655, -478, 10512, -566, -655, 7001, -655, -655, -655, -655, 5099, 10690, 5270, 10075, -655, -655, -655, -655, -2802, -655, 2452, 7772, -655, -655, -655, -655, 8590, -2086, -1446, 7417, -655, -655, -655, -655, -7873, 9752, -115, -567, -655, -655, -655, -655, 3918, 5568, 474, 10692, -655, -655, -655, -655, -6346, 9732, 10584, 5012, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, 5401, 1303, 10692, 10692, -655, -655, -655, -655, -655, -151, 7207, 9458, -655, -655, -655, -655, 1584, 714, 10262, 10395, -655, -655, -655, -655, -165, 3294, 4773, 5541, -655, -655, -655, -655, 2222, -300, 3693, 9239, -655, -655, -655, -655, 2340, -6982, 3461, 10692, -655, -655, -655, -655, -655, -4523, 5284, 2337, -655, -655, -655, -655, -655, -655, 9026, -655, -655, -655, -655, -655, -655, -655, 9373, -655, -655, -655, -655, -5908, -647, -4930, 6384, 5296, -655, -655, -655, -8221, 1730, 1698, 6502, 10601, -655, -655, -655, -13, -4546, 1903, 7768, 10338, -655, -655, -655, -6062, -9673, -3172, 6354, 10692, -655, -655, -655, -522, -6332, -7504, 4275, 10667, -655, -655, -655, -9242, 3979, -655, 9729, 2430, -655, -655, -655, 2483, -655, 1198, 1339, 10591, -655, -655, -655, -4697, -655, -655, -655, -655, -655, -655, -655, -2681, -7180, 1766, 8877, 9976, -655, -655, -655, 5196, -6719, -6907, -478, 4620, -655, -655, -655, 4030, -8326, 2160, 7600, 6113, -655, -655, -655, -6787, -855, -2925, 10692, 10169, -655, -655, -655, -5233, -8587, -2133, 8096, 10692, -655, -655, -655, -6920, -3351, -792, 7843, 10013, -655, -655, -655, -238, -3213, -2421, 539, 9794, -655, -655, -655, 3663, 185, 3222, -655, 6403, -655, -655, -655, -3569, 2633, 5166, 5992, 6706, -655, -655, -655, 400, 6073, 4380, 10615, 10692, -655, -655, -655, 2799, 2114, -576, 7411, 9451, -655, -655, -655, 3242, -4882, -3786, 6947, 10692, -655, -655, -655, 186, 7565, 5554, 10340, 9478, -655, -655, -655, -1766, -1975, 2874, -2106, 6323, -655, -655, -655, -5445, 3547, 7092, -2662, 10692, -655, -655, -655, -7191, -3862, 5403, 1941, 6137, -655, -655, -655, -1134, 2119, 2767, 10505, 9805, -655, -655, -655, 2413, -2197, -3547, 9062, 10549, -655, -655, -655, -1535, 132, 7557, 10019, 10692, -655, -655, -655, -3427, 247, 6814, 8439, 10692, -655, -655, -655, 3726, -3350, -815, -3792, 7445, -655, -655, -655, -5793, 10656, 5413, 8763, 4516, -655, -655, -655, 4008, -112, -16, -655, 9691, -655, -655, -655, 9534, 6377, 3501, 6080, 10692, -655, -655, -655, 2299, 90, 5188, 7946, 10692, -655, -655, -655, -1799, 4739, 9588, 610, 8814, -655, -655, -655, 6483, 6023, 10345, 7772, 7775, -655, -655, -655, 1248, 5596, 9620, 8740, 4206, -655, -655, -655, 10238, 7329, 9012, 6234, 10677, -655, -655, -655, 4125, 3173, 8678, -222, 9398, -655, -655, -655, -655, -1527, -272, -655, 3479, -655, -655, -655, 184, -655, 8276, 8230, 7454, -655, -655, -655, 2149, 1696, 9901, 10692, 10692, -655, -655, -655, -385, 4677, 3493, 7335, 3303, -655, -655, -655, -1176, 2128, 9988, 9780, 10692, -655, -655, -655, 9477, 7296, 7800, 10665, 10692, -655, -655, -655, -2655, 3717, 3770, 6817, 10627, -655, -655, -655, 8654, 4689, 10659, 10654, 10692, -655, -655, -655, -2236, 10658, 2464, 2979, 10677, -655, -655, -655, -478, 8496, 5255, 10655, 10692, -655, -655, -655, -655, 404, 9451, 9817, 10684, -655, -655, -655, -655, 7877, 2676, 4088, 10692, -655, -655, -655, -655, 5479, 5702, 10692, 10692, -655, -655, -655, -655, 2713, 2894, 10692, 10635, -655, -655, -655, -655, 7226, 10668, 10161, 7784, -655, -655, -655, -655, 757, 2388, 9973, 8002, -655, -655, -655, -655, 4917, 10692, 10692, 10476, -655, -655, -655, -655, -3397, 8808, 1037, 9008, -655, -655, -655, -655, -655, 3160, 9762, 3185, -655, -655, -655, -655, 3957, 2909, 10663, 7822, -655, -655, -655, -655, 185, 10692, 6916, 2851, -655, -655, -655, -655, -222, -4345, 9773, 7152, -655, -655, -655, -655, 1229, -655, 6272, 3671, -655, -655, -655, -655, 897, -3996, 9402, 6342, -655, -655, -655, -655, 8889, -655, 10692, 5597, -655, -655, -655, -655, -655, -655, 8897, -566, -655, -655, -655, -947, 4265, -655, 10647, 4620, -655, -655, -655, 5441, 2076, 8497, 7796, 9622, -655, -655, -655, 978, 4003, 10032, 9896, 10692, -655, -655, -655, -10441, -2914, 6545, 1974, 1540, -655, -655, -655, -5425, -944, -3616, 3650, 1899, -655, -655, -655, 8239, 7204, 9098, 9789, 870, -655, -655, -655, 5543, -272, 10692, 3125, -8857, -655, -655, -655, -4075, 8799, -655, 8447, -1137, -655, -655, -655, 2440, 8708, 10204, 5117, 9090, -655, -655, -655, -4602, 8383, -3215, 1568, 3064, -655, -655, -655, -799, 10402, 8950, 9182, 9952, -655, -655, -655, 3093, 7704, 3667, 8397, 6673, -655, -655, -655, 3823, 669, 6396, 3626, 1621, -655, -655, -655, -2228, -10075, 10662, -655, 6428, -655, -655, -655, 7265, 1814, 5039, -6660, 7991, -655, -655, -655, 3445, 4537, 9769, -655, 6073, -655, -655, -655, 3432, 10648, 10692, 8627, 10663, -655, -655, -655, 2421, 2040, 10692, 10619, 10692, -655, -655, -655, 3459, 6740, 10405, 4984, 9567, -655, -655, -655, 4130, 5855, 9589, 8788, 7875, -655, -655, -655, 9781, 10478, 8613, 10422, 7235, -655, -655, -655, 8143, 4058, 9635, 2518, 6595, -655, -655, -655, 3062, 9413, 8923, 5221, -644, -655, -655, -655, 9249, 10530, 9436, 9144, 10692, -655, -655, -655, -2422, 2498, 10599, 9722, 7774, -655, -655, -655, -1525, 10178, 7190, 9831, 8661, -655, -655, -655, -7846, 7215, 6430, 10614, 10692, -655, -655, -655, 1210, 9004, 10484, 161, 7703, -655, -655, -655, 3501, 10582, 10633, 7869, 2459, -655, -655, -655, -2278, 8914, 10692, 9897, 10356, -655, -655, -655, 8409, 10685, 5159, 5927, 7508, -655, -655, -655, 7744, 6106, -6311, 810, 10692, -655, -655, -655, -5039, 7357, 6074, 8287, 9299, -655, -655, -655, 7222, 9563, 9844, 8382, 3175, -655, -655, -655, -458, 7269, 2868, 6546, 9604, -655, -655, -655, 1353, 8192, 5231, 9530, 10692, -655, -655, -655, 6720, 9573, 10104, 10218, 10666, -655, -655, -655, -1645, 10692, 9437, 8695, 10692, -655, -655, -655, -1940, 2331, 10221, 63, 9721, -655, -655, -655, 9486, 3768, 9459, -655, 3606, -655, -655, -655, 800, 7751, 8113, 10692, 10670, -655, -655, -655, 6964, 10688, 10303, 9472, 10442, -655, -655, -655, 9369, 10692, 9184, 9972, 10603, -655, -655, -655, 5923, 4074, 10635, 10371, 10692, -655, -655, -655, 6056, 10147, 5238, 9688, 10692, -655, -655, -655, 10548, 3728, 934, 10177, 10692, -655, -655, -655, 5599, 10594, 10319, 10692, 10692, -655, -655, -655, -184, 1429, 10674, 1229, 10692, -655, -655, -655, -655, 10108, 10679, 9444, 10692, -655, -655, -655, -655, 4234, 5369, 9379, 10682, -655, -655, -655, -655, 7657, 6805, 10402, 10692, -655, -655, -655, -655, 7170, 10, 9606, 10692, -655, -655, -655, -655, 479, 6438, 9829, 10692, -655, -655, -655, -655, -5869, 5909, 10635, 10692, -655, -655, -655, -655, -2662, 6500, 6380, 10599, -655, -655, -655, -655, 10101, 9398, 10402, 10692, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -66, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -566, -655, -655, -655, -655, -655, -655, -655, -1279, 2317, -655, -655, -655, -655, -655, -655, 543, -655, 2841, -655, -655, -655, -655, -655, -1993, -655, -655, -655, -655, -655, -655, -655, -7468, 202, -655, -655, -655, -655, -655, -655, -1405, -655, 6447, -655, -272, -655, -655, -655, -391, -655, -655, -655, -655, -655, -655, -655, 1377, -655, 264, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, 4711, 7967, 1953, 714, -655, -655, -655, -655, 459, 569, 3170, -358, -566, -655, -655, -655, -707, 9813, 10549, -655, 6410, -655, -655, -655, -4703, 5274, 7088, 10426, 8553, -655, -655, -655, -53, -358, 816, -655, 4858, -655, -655, -655, 2218, -642, 7003, -655, -272, -655, -655, -655, -655, 682, 3355, -655, 10367, -655, -655, -655, -655, -655, 6974, -478, -655, -655, -655, -655, -566, 5924, 698, -655, 141, -655, -655, -655, 3017, 10673, 5385, 7072, 8316, -655, -655, -655, 5831, 9383, 10692, 9062, 10692, -655, -655, -655, 4660, 7807, 8379, 10116, 10692, -655, -655, -655, -211, -895, 2955, 4023, 10692, -655, -655, -655, -659, 7326, 9755, -655, 10692, -655, -655, -655, 4965, 1224, 10692, -655, 10692, -655, -655, -655, -655, 28, 3466, 315, 9498, -655, -655, -655, 10595, 9473, 10692, 9682, 10688, -655, -655, -655, 6463, 10420, 10689, 10608, 10684, -655, -655, -655, 10538, 2712, 9907, 10404, 10692, -655, -655, -655, -4882, 4921, 2549, 10264, 10692, -655, -655, -655, 10692, 6055, 10692, 9716, 10692, -655, -655, -655, -7398, 8357, 10622, 10692, 10692, -655, -655, -655, 8744, 8207, 10678, 10680, 10692, -655, -655, -655, -655, -655, 845, -655, -478, -655, -655, -655, -655, -655, -655, 3154, 6001, -655, -655, -655, -655, -1783, 3759, 6022, 6337, -655, -655, -655, -655, 6309, 4415, 10692, 10692, -655, -655, -655, -655, 10473, 8767, 8942, 10692, -655, -655, -655, -655, -1, 8086, 10515, 10692, -655, -655, -655, -655, 7217, 4009, 8013, 10692, -655, -655, -655, -655, 6278, 154, 10692, 10692, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655, -655,
};

TUNE(SetRange(-10692, 10692), savedCaptureHistory);

namespace TB = Tablebases;

void syzygy_extend_pv(const OptionsMap&            options,
                      const Search::LimitsType&    limits,
                      Stockfish::Position&         pos,
                      Stockfish::Search::RootMove& rootMove,
                      Value&                       v);

using namespace Search;

namespace {

// (*Scalers):
// The values with Scaler asterisks have proven non-linear scaling.
// They are optimized to time controls of 180 + 1.8 and longer,
// so changing them or adding conditions that are similar requires
// tests at these types of time controls.

// Futility margin
Value futility_margin(Depth d, bool noTtCutNode, bool improving, bool oppWorsening) {
    Value futilityMult       = 112 - 26 * noTtCutNode;
    Value improvingDeduction = improving * futilityMult * 2;
    Value worseningDeduction = oppWorsening * futilityMult / 3;

    return futilityMult * d - improvingDeduction - worseningDeduction;
}

constexpr int futility_move_count(bool improving, Depth depth) {
    return (3 + depth * depth) / (2 - improving);
}

int correction_value(const Worker& w, const Position& pos, const Stack* const ss) {
    const Color us    = pos.side_to_move();
    const auto  m     = (ss - 1)->currentMove;
    const auto  pcv   = w.pawnCorrectionHistory[pawn_structure_index<Correction>(pos)][us];
    const auto  micv  = w.minorPieceCorrectionHistory[minor_piece_index(pos)][us];
    const auto  wnpcv = w.nonPawnCorrectionHistory[WHITE][non_pawn_index<WHITE>(pos)][us];
    const auto  bnpcv = w.nonPawnCorrectionHistory[BLACK][non_pawn_index<BLACK>(pos)][us];
    const auto  cntcv =
      m.is_ok() ? (*(ss - 2)->continuationCorrectionHistory)[pos.piece_on(m.to_sq())][m.to_sq()]
                 : 0;

    return 6995 * pcv + 6593 * micv + 7753 * (wnpcv + bnpcv) + 6049 * cntcv;
}

int risk_tolerance(const Position& pos, Value v) {
    // Returns (some constant of) second derivative of sigmoid.
    static constexpr auto sigmoid_d2 = [](int x, int y) {
        return -345600 * x / (x * x + 3 * y * y);
    };

    int material = pos.count<PAWN>() + 3 * pos.count<KNIGHT>() + 3 * pos.count<BISHOP>()
                 + 5 * pos.count<ROOK>() + 9 * pos.count<QUEEN>();

    int m = std::clamp(material, 17, 78);

    // a and b are the crude approximation of the wdl model.
    // The win rate is: 1/(1+exp((a-v)/b))
    // The loss rate is 1/(1+exp((v+a)/b))
    int a = ((-m * 3220 / 256 + 2361) * m / 256 - 586) * m / 256 + 421;
    int b = ((m * 7761 / 256 - 2674) * m / 256 + 314) * m / 256 + 51;


    // The risk utility is therefore d/dv^2 (1/(1+exp(-(v-a)/b)) -1/(1+exp(-(-v-a)/b)))
    // -115200x/(x^2+3) = -345600(ab) / (a^2+3b^2) (multiplied by some constant) (second degree pade approximant)
    int winning_risk = sigmoid_d2(v - a, b);
    int losing_risk  = -sigmoid_d2(-v - a, b);

    return (winning_risk + losing_risk) * 60 / b;
}

// Add correctionHistory value to raw staticEval and guarantee evaluation
// does not hit the tablebase range.
Value to_corrected_static_eval(const Value v, const int cv) {
    return std::clamp(v + cv / 131072, VALUE_TB_LOSS_IN_MAX_PLY + 1, VALUE_TB_WIN_IN_MAX_PLY - 1);
}

void update_correction_history(const Position& pos,
                               Stack* const    ss,
                               Search::Worker& workerThread,
                               const int       bonus) {
    const Move  m  = (ss - 1)->currentMove;
    const Color us = pos.side_to_move();

    static constexpr int nonPawnWeight = 165;

    workerThread.pawnCorrectionHistory[pawn_structure_index<Correction>(pos)][us]
      << bonus * 109 / 128;
    workerThread.minorPieceCorrectionHistory[minor_piece_index(pos)][us] << bonus * 141 / 128;
    workerThread.nonPawnCorrectionHistory[WHITE][non_pawn_index<WHITE>(pos)][us]
      << bonus * nonPawnWeight / 128;
    workerThread.nonPawnCorrectionHistory[BLACK][non_pawn_index<BLACK>(pos)][us]
      << bonus * nonPawnWeight / 128;

    if (m.is_ok())
        (*(ss - 2)->continuationCorrectionHistory)[pos.piece_on(m.to_sq())][m.to_sq()]
          << bonus * 138 / 128;
}

// Add a small random component to draw evaluations to avoid 3-fold blindness
Value value_draw(size_t nodes) { return VALUE_DRAW - 1 + Value(nodes & 0x2); }
Value value_to_tt(Value v, int ply);
Value value_from_tt(Value v, int ply, int r50c);
void  update_pv(Move* pv, Move move, const Move* childPv);
void  update_continuation_histories(Stack* ss, Piece pc, Square to, int bonus);
void  update_quiet_histories(
   const Position& pos, Stack* ss, Search::Worker& workerThread, Move move, int bonus);
void update_all_stats(const Position&      pos,
                      Stack*               ss,
                      Search::Worker&      workerThread,
                      Move                 bestMove,
                      Square               prevSq,
                      ValueList<Move, 32>& quietsSearched,
                      ValueList<Move, 32>& capturesSearched,
                      Depth                depth,
                      bool                 isTTMove,
                      int                  moveCount);

}  // namespace

Search::Worker::Worker(SharedState&                    sharedState,
                       std::unique_ptr<ISearchManager> sm,
                       size_t                          threadId,
                       NumaReplicatedAccessToken       token) :
    // Unpack the SharedState struct into member variables
    threadIdx(threadId),
    numaAccessToken(token),
    manager(std::move(sm)),
    options(sharedState.options),
    threads(sharedState.threads),
    tt(sharedState.tt),
    networks(sharedState.networks),
    refreshTable(networks[token]) {
    clear();
}

void Search::Worker::ensure_network_replicated() {
    // Access once to force lazy initialization.
    // We do this because we want to avoid initialization during search.
    (void) (networks[numaAccessToken]);
}

void Search::Worker::start_searching() {

    // Non-main threads go directly to iterative_deepening()
    if (!is_mainthread())
    {
        iterative_deepening();
        return;
    }

    main_manager()->tm.init(limits, rootPos.side_to_move(), rootPos.game_ply(), options,
                            main_manager()->originalTimeAdjust);
    tt.new_search();

    if (rootMoves.empty())
    {
        rootMoves.emplace_back(Move::none());
        main_manager()->updates.onUpdateNoMoves(
          {0, {rootPos.checkers() ? -VALUE_MATE : VALUE_DRAW, rootPos}});
    }
    else
    {
        threads.start_searching();  // start non-main threads
        iterative_deepening();      // main thread start searching
    }

    // When we reach the maximum depth, we can arrive here without a raise of
    // threads.stop. However, if we are pondering or in an infinite search,
    // the UCI protocol states that we shouldn't print the best move before the
    // GUI sends a "stop" or "ponderhit" command. We therefore simply wait here
    // until the GUI sends one of those commands.
    while (!threads.stop && (main_manager()->ponder || limits.infinite))
    {}  // Busy wait for a stop or a ponder reset

    // Stop the threads if not already stopped (also raise the stop if
    // "ponderhit" just reset threads.ponder)
    threads.stop = true;

    // Wait until all threads have finished
    threads.wait_for_search_finished();

    // When playing in 'nodes as time' mode, subtract the searched nodes from
    // the available ones before exiting.
    if (limits.npmsec)
        main_manager()->tm.advance_nodes_time(threads.nodes_searched()
                                              - limits.inc[rootPos.side_to_move()]);

    Worker* bestThread = this;
    Skill   skill =
      Skill(options["Skill Level"], options["UCI_LimitStrength"] ? int(options["UCI_Elo"]) : 0);

    if (int(options["MultiPV"]) == 1 && !limits.depth && !limits.mate && !skill.enabled()
        && rootMoves[0].pv[0] != Move::none())
        bestThread = threads.get_best_thread()->worker.get();

    main_manager()->bestPreviousScore        = bestThread->rootMoves[0].score;
    main_manager()->bestPreviousAverageScore = bestThread->rootMoves[0].averageScore;

    // Send again PV info if we have a new best thread
    if (bestThread != this)
        main_manager()->pv(*bestThread, threads, tt, bestThread->completedDepth);

    std::string ponder;

    if (bestThread->rootMoves[0].pv.size() > 1
        || bestThread->rootMoves[0].extract_ponder_from_tt(tt, rootPos))
        ponder = UCIEngine::move(bestThread->rootMoves[0].pv[1], rootPos.is_chess960());

    auto bestmove = UCIEngine::move(bestThread->rootMoves[0].pv[0], rootPos.is_chess960());
    main_manager()->updates.onBestmove(bestmove, ponder);
}

// Main iterative deepening loop. It calls search()
// repeatedly with increasing depth until the allocated thinking time has been
// consumed, the user stops the search, or the maximum search depth is reached.
void Search::Worker::iterative_deepening() {

    SearchManager* mainThread = (is_mainthread() ? main_manager() : nullptr);

    Move pv[MAX_PLY + 1];

    Depth lastBestMoveDepth = 0;
    Value lastBestScore     = -VALUE_INFINITE;
    auto  lastBestPV        = std::vector{Move::none()};

    Value  alpha, beta;
    Value  bestValue     = -VALUE_INFINITE;
    Color  us            = rootPos.side_to_move();
    double timeReduction = 1, totBestMoveChanges = 0;
    int    delta, iterIdx                        = 0;

    // Allocate stack with extra size to allow access from (ss - 7) to (ss + 2):
    // (ss - 7) is needed for update_continuation_histories(ss - 1) which accesses (ss - 6),
    // (ss + 2) is needed for initialization of cutOffCnt.
    Stack  stack[MAX_PLY + 10] = {};
    Stack* ss                  = stack + 7;

    for (int i = 7; i > 0; --i)
    {
        (ss - i)->continuationHistory =
          &this->continuationHistory[0][0][NO_PIECE][0];  // Use as a sentinel
        (ss - i)->continuationCorrectionHistory = &this->continuationCorrectionHistory[NO_PIECE][0];
        (ss - i)->staticEval                    = VALUE_NONE;
        (ss - i)->reduction                     = 0;
    }

    for (int i = 0; i <= MAX_PLY + 2; ++i)
    {
        (ss + i)->ply       = i;
        (ss + i)->reduction = 0;
    }

    ss->pv = pv;

    if (mainThread)
    {
        if (mainThread->bestPreviousScore == VALUE_INFINITE)
            mainThread->iterValue.fill(VALUE_ZERO);
        else
            mainThread->iterValue.fill(mainThread->bestPreviousScore);
    }

    size_t multiPV = size_t(options["MultiPV"]);
    Skill skill(options["Skill Level"], options["UCI_LimitStrength"] ? int(options["UCI_Elo"]) : 0);

    // When playing with strength handicap enable MultiPV search that we will
    // use behind-the-scenes to retrieve a set of possible moves.
    if (skill.enabled())
        multiPV = std::max(multiPV, size_t(4));

    multiPV = std::min(multiPV, rootMoves.size());

    int searchAgainCounter = 0;

    lowPlyHistory.fill(95);

    // Iterative deepening loop until requested to stop or the target depth is reached
    while (++rootDepth < MAX_PLY && !threads.stop
           && !(limits.depth && mainThread && rootDepth > limits.depth))
    {
        // Age out PV variability metric
        if (mainThread)
            totBestMoveChanges /= 2;

        // Save the last iteration's scores before the first PV line is searched and
        // all the move scores except the (new) PV are set to -VALUE_INFINITE.
        for (RootMove& rm : rootMoves)
            rm.previousScore = rm.score;

        size_t pvFirst = 0;
        pvLast         = 0;

        if (!threads.increaseDepth)
            searchAgainCounter++;

        // MultiPV loop. We perform a full root search for each PV line
        for (pvIdx = 0; pvIdx < multiPV; ++pvIdx)
        {
            if (pvIdx == pvLast)
            {
                pvFirst = pvLast;
                for (pvLast++; pvLast < rootMoves.size(); pvLast++)
                    if (rootMoves[pvLast].tbRank != rootMoves[pvFirst].tbRank)
                        break;
            }

            // Reset UCI info selDepth for each depth and each PV line
            selDepth = 0;

            // Reset aspiration window starting size
            delta     = 5 + std::abs(rootMoves[pvIdx].meanSquaredScore) / 13000;
            Value avg = rootMoves[pvIdx].averageScore;
            alpha     = std::max(avg - delta, -VALUE_INFINITE);
            beta      = std::min(avg + delta, VALUE_INFINITE);

            // Adjust optimism based on root move's averageScore
            optimism[us]  = 138 * avg / (std::abs(avg) + 81);
            optimism[~us] = -optimism[us];

            // Start with a small aspiration window and, in the case of a fail
            // high/low, re-search with a bigger window until we don't fail
            // high/low anymore.
            int failedHighCnt = 0;
            while (true)
            {
                // Adjust the effective depth searched, but ensure at least one
                // effective increment for every four searchAgain steps (see issue #2717).
                Depth adjustedDepth =
                  std::max(1, rootDepth - failedHighCnt - 3 * (searchAgainCounter + 1) / 4);
                rootDelta = beta - alpha;
                bestValue = search<Root>(rootPos, ss, alpha, beta, adjustedDepth, false);

                // Bring the best move to the front. It is critical that sorting
                // is done with a stable algorithm because all the values but the
                // first and eventually the new best one is set to -VALUE_INFINITE
                // and we want to keep the same order for all the moves except the
                // new PV that goes to the front. Note that in the case of MultiPV
                // search the already searched PV lines are preserved.
                std::stable_sort(rootMoves.begin() + pvIdx, rootMoves.begin() + pvLast);

                // If search has been stopped, we break immediately. Sorting is
                // safe because RootMoves is still valid, although it refers to
                // the previous iteration.
                if (threads.stop)
                    break;

                // When failing high/low give some update before a re-search. To avoid
                // excessive output that could hang GUIs like Fritz 19, only start
                // at nodes > 10M (rather than depth N, which can be reached quickly)
                if (mainThread && multiPV == 1 && (bestValue <= alpha || bestValue >= beta)
                    && nodes > 10000000)
                    main_manager()->pv(*this, threads, tt, rootDepth);

                // In case of failing low/high increase aspiration window and re-search,
                // otherwise exit the loop.
                if (bestValue <= alpha)
                {
                    beta  = (alpha + beta) / 2;
                    alpha = std::max(bestValue - delta, -VALUE_INFINITE);

                    failedHighCnt = 0;
                    if (mainThread)
                        mainThread->stopOnPonderhit = false;
                }
                else if (bestValue >= beta)
                {
                    beta = std::min(bestValue + delta, VALUE_INFINITE);
                    ++failedHighCnt;
                }
                else
                    break;

                delta += delta / 3;

                assert(alpha >= -VALUE_INFINITE && beta <= VALUE_INFINITE);
            }

            // Sort the PV lines searched so far and update the GUI
            std::stable_sort(rootMoves.begin() + pvFirst, rootMoves.begin() + pvIdx + 1);

            if (mainThread
                && (threads.stop || pvIdx + 1 == multiPV || nodes > 10000000)
                // A thread that aborted search can have mated-in/TB-loss PV and
                // score that cannot be trusted, i.e. it can be delayed or refuted
                // if we would have had time to fully search other root-moves. Thus
                // we suppress this output and below pick a proven score/PV for this
                // thread (from the previous iteration).
                && !(threads.abortedSearch && is_loss(rootMoves[0].uciScore)))
                main_manager()->pv(*this, threads, tt, rootDepth);

            if (threads.stop)
                break;
        }

        if (!threads.stop)
            completedDepth = rootDepth;

        // We make sure not to pick an unproven mated-in score,
        // in case this thread prematurely stopped search (aborted-search).
        if (threads.abortedSearch && rootMoves[0].score != -VALUE_INFINITE
            && is_loss(rootMoves[0].score))
        {
            // Bring the last best move to the front for best thread selection.
            Utility::move_to_front(rootMoves, [&lastBestPV = std::as_const(lastBestPV)](
                                                const auto& rm) { return rm == lastBestPV[0]; });
            rootMoves[0].pv    = lastBestPV;
            rootMoves[0].score = rootMoves[0].uciScore = lastBestScore;
        }
        else if (rootMoves[0].pv[0] != lastBestPV[0])
        {
            lastBestPV        = rootMoves[0].pv;
            lastBestScore     = rootMoves[0].score;
            lastBestMoveDepth = rootDepth;
        }

        if (!mainThread)
            continue;

        // Have we found a "mate in x"?
        if (limits.mate && rootMoves[0].score == rootMoves[0].uciScore
            && ((rootMoves[0].score >= VALUE_MATE_IN_MAX_PLY
                 && VALUE_MATE - rootMoves[0].score <= 2 * limits.mate)
                || (rootMoves[0].score != -VALUE_INFINITE
                    && rootMoves[0].score <= VALUE_MATED_IN_MAX_PLY
                    && VALUE_MATE + rootMoves[0].score <= 2 * limits.mate)))
            threads.stop = true;

        // If the skill level is enabled and time is up, pick a sub-optimal best move
        if (skill.enabled() && skill.time_to_pick(rootDepth))
            skill.pick_best(rootMoves, multiPV);

        // Use part of the gained time from a previous stable move for the current move
        for (auto&& th : threads)
        {
            totBestMoveChanges += th->worker->bestMoveChanges;
            th->worker->bestMoveChanges = 0;
        }

        // Do we have time for the next iteration? Can we stop searching now?
        if (limits.use_time_management() && !threads.stop && !mainThread->stopOnPonderhit)
        {
            int nodesEffort = rootMoves[0].effort * 100000 / std::max(size_t(1), size_t(nodes));

            double fallingEval =
              (11.396 + 2.035 * (mainThread->bestPreviousAverageScore - bestValue)
               + 0.968 * (mainThread->iterValue[iterIdx] - bestValue))
              / 100.0;
            fallingEval = std::clamp(fallingEval, 0.5786, 1.6752);

            // If the bestMove is stable over several iterations, reduce time accordingly
            timeReduction = lastBestMoveDepth + 8 < completedDepth ? 1.4857 : 0.7046;
            double reduction =
              (1.4540 + mainThread->previousTimeReduction) / (2.1593 * timeReduction);
            double bestMoveInstability = 0.9929 + 1.8519 * totBestMoveChanges / threads.size();

            double totalTime =
              mainThread->tm.optimum() * fallingEval * reduction * bestMoveInstability;

            // Cap used time in case of a single legal move for a better viewer experience
            if (rootMoves.size() == 1)
                totalTime = std::min(500.0, totalTime);

            auto elapsedTime = elapsed();

            if (completedDepth >= 10 && nodesEffort >= 97056 && elapsedTime > totalTime * 0.6540
                && !mainThread->ponder)
                threads.stop = true;

            // Stop the search if we have exceeded the totalTime or maximum
            if (elapsedTime > std::min(totalTime, double(mainThread->tm.maximum())))
            {
                // If we are allowed to ponder do not stop the search now but
                // keep pondering until the GUI sends "ponderhit" or "stop".
                if (mainThread->ponder)
                    mainThread->stopOnPonderhit = true;
                else
                    threads.stop = true;
            }
            else
                threads.increaseDepth = mainThread->ponder || elapsedTime <= totalTime * 0.5138;
        }

        mainThread->iterValue[iterIdx] = bestValue;
        iterIdx                        = (iterIdx + 1) & 3;
    }

    if (!mainThread)
        return;

    // int16_t arr[16*64*8] = {};
    // int16_t* arr_ptr = arr;

    // captureHistory.save(arr_ptr);

    // for (int i = 0; i < 16*64*8; i++){
    //     std::cout << (int)arr[i] << ", ";
    // }

    mainThread->previousTimeReduction = timeReduction;

    // If the skill level is enabled, swap the best PV line with the sub-optimal one
    if (skill.enabled())
        std::swap(rootMoves[0],
                  *std::find(rootMoves.begin(), rootMoves.end(),
                             skill.best ? skill.best : skill.pick_best(rootMoves, multiPV)));
}

// Reset histories, usually before a new game
void Search::Worker::clear() {
    mainHistory.fill(65);
    lowPlyHistory.fill(107);

    int* savedCaptureHistoryPtr = savedCaptureHistory;
    captureHistory.load(savedCaptureHistoryPtr);

    pawnHistory.fill(-1215);
    pawnCorrectionHistory.fill(4);
    minorPieceCorrectionHistory.fill(0);
    nonPawnCorrectionHistory[WHITE].fill(0);
    nonPawnCorrectionHistory[BLACK].fill(0);

    for (auto& to : continuationCorrectionHistory)
        for (auto& h : to)
            h.fill(0);

    for (bool inCheck : {false, true})
        for (StatsType c : {NoCaptures, Captures})
            for (auto& to : continuationHistory[inCheck][c])
                for (auto& h : to)
                    h.fill(-493);

    for (size_t i = 1; i < reductions.size(); ++i)
        reductions[i] = int(2937 / 128.0 * std::log(i));

    refreshTable.clear(networks[numaAccessToken]);
}


// Main search function for both PV and non-PV nodes
template<NodeType nodeType>
Value Search::Worker::search(
  Position& pos, Stack* ss, Value alpha, Value beta, Depth depth, bool cutNode) {

    constexpr bool PvNode   = nodeType != NonPV;
    constexpr bool rootNode = nodeType == Root;
    const bool     allNode  = !(PvNode || cutNode);

    // Dive into quiescence search when the depth reaches zero
    if (depth <= 0)
    {
        constexpr auto nt = PvNode ? PV : NonPV;
        return qsearch<nt>(pos, ss, alpha, beta);
    }

    // Limit the depth if extensions made it too large
    depth = std::min(depth, MAX_PLY - 1);

    // Check if we have an upcoming move that draws by repetition
    if (!rootNode && alpha < VALUE_DRAW && pos.upcoming_repetition(ss->ply))
    {
        alpha = value_draw(this->nodes);
        if (alpha >= beta)
            return alpha;
    }

    assert(-VALUE_INFINITE <= alpha && alpha < beta && beta <= VALUE_INFINITE);
    assert(PvNode || (alpha == beta - 1));
    assert(0 < depth && depth < MAX_PLY);
    assert(!(PvNode && cutNode));

    Move      pv[MAX_PLY + 1];
    StateInfo st;
    ASSERT_ALIGNED(&st, Eval::NNUE::CacheLineSize);

    Key   posKey;
    Move  move, excludedMove, bestMove;
    Depth extension, newDepth;
    Value bestValue, value, eval, maxValue, probCutBeta;
    bool  givesCheck, improving, priorCapture, opponentWorsening;
    bool  capture, ttCapture;
    int   priorReduction = (ss - 1)->reduction;
    (ss - 1)->reduction  = 0;
    Piece movedPiece;

    ValueList<Move, 32> capturesSearched;
    ValueList<Move, 32> quietsSearched;

    // Step 1. Initialize node
    Worker* thisThread = this;
    ss->inCheck        = pos.checkers();
    priorCapture       = pos.captured_piece();
    Color us           = pos.side_to_move();
    ss->moveCount      = 0;
    bestValue          = -VALUE_INFINITE;
    maxValue           = VALUE_INFINITE;

    // Check for the available remaining time
    if (is_mainthread())
        main_manager()->check_time(*thisThread);

    // Used to send selDepth info to GUI (selDepth counts from 1, ply from 0)
    if (PvNode && thisThread->selDepth < ss->ply + 1)
        thisThread->selDepth = ss->ply + 1;

    if (!rootNode)
    {
        // Step 2. Check for aborted search and immediate draw
        if (threads.stop.load(std::memory_order_relaxed) || pos.is_draw(ss->ply)
            || ss->ply >= MAX_PLY)
            return (ss->ply >= MAX_PLY && !ss->inCheck) ? evaluate(pos)
                                                        : value_draw(thisThread->nodes);

        // Step 3. Mate distance pruning. Even if we mate at the next move our score
        // would be at best mate_in(ss->ply + 1), but if alpha is already bigger because
        // a shorter mate was found upward in the tree then there is no need to search
        // because we will never beat the current alpha. Same logic but with reversed
        // signs apply also in the opposite condition of being mated instead of giving
        // mate. In this case, return a fail-high score.
        alpha = std::max(mated_in(ss->ply), alpha);
        beta  = std::min(mate_in(ss->ply + 1), beta);
        if (alpha >= beta)
            return alpha;
    }

    assert(0 <= ss->ply && ss->ply < MAX_PLY);

    bestMove            = Move::none();
    (ss + 2)->cutoffCnt = 0;
    Square prevSq = ((ss - 1)->currentMove).is_ok() ? ((ss - 1)->currentMove).to_sq() : SQ_NONE;
    ss->statScore = 0;

    // Step 4. Transposition table lookup
    excludedMove                   = ss->excludedMove;
    posKey                         = pos.key();
    auto [ttHit, ttData, ttWriter] = tt.probe(posKey);
    // Need further processing of the saved data
    ss->ttHit    = ttHit;
    ttData.move  = rootNode ? thisThread->rootMoves[thisThread->pvIdx].pv[0]
                 : ttHit    ? ttData.move
                            : Move::none();
    ttData.value = ttHit ? value_from_tt(ttData.value, ss->ply, pos.rule50_count()) : VALUE_NONE;
    ss->ttPv     = excludedMove ? ss->ttPv : PvNode || (ttHit && ttData.is_pv);
    ttCapture    = ttData.move && pos.capture_stage(ttData.move);

    // At this point, if excluded, skip straight to step 6, static eval. However,
    // to save indentation, we list the condition in all code between here and there.

    // At non-PV nodes we check for an early TT cutoff
    if (!PvNode && !excludedMove && ttData.depth > depth - (ttData.value <= beta)
        && is_valid(ttData.value)  // Can happen when !ttHit or when access race in probe()
        && (ttData.bound & (ttData.value >= beta ? BOUND_LOWER : BOUND_UPPER))
        && (cutNode == (ttData.value >= beta) || depth > 5))
    {
        // If ttMove is quiet, update move sorting heuristics on TT hit
        if (ttData.move && ttData.value >= beta)
        {
            // Bonus for a quiet ttMove that fails high
            if (!ttCapture)
                update_quiet_histories(pos, ss, *this, ttData.move,
                                       std::min(117600 * depth - 71344, 1244992) / 1024);

            // Extra penalty for early quiet moves of the previous ply
            if (prevSq != SQ_NONE && (ss - 1)->moveCount <= 3 && !priorCapture)
                update_continuation_histories(ss - 1, pos.piece_on(prevSq), prevSq,
                                              -std::min(779788 * (depth + 1) - 271806, 2958308)
                                                / 1024);
        }

        // Partial workaround for the graph history interaction problem
        // For high rule50 counts don't produce transposition table cutoffs.
        if (pos.rule50_count() < 90)
            return ttData.value;
    }

    // Step 5. Tablebases probe
    if (!rootNode && !excludedMove && tbConfig.cardinality)
    {
        int piecesCount = pos.count<ALL_PIECES>();

        if (piecesCount <= tbConfig.cardinality
            && (piecesCount < tbConfig.cardinality || depth >= tbConfig.probeDepth)
            && pos.rule50_count() == 0 && !pos.can_castle(ANY_CASTLING))
        {
            TB::ProbeState err;
            TB::WDLScore   wdl = Tablebases::probe_wdl(pos, &err);

            // Force check of time on the next occasion
            if (is_mainthread())
                main_manager()->callsCnt = 0;

            if (err != TB::ProbeState::FAIL)
            {
                thisThread->tbHits.fetch_add(1, std::memory_order_relaxed);

                int drawScore = tbConfig.useRule50 ? 1 : 0;

                Value tbValue = VALUE_TB - ss->ply;

                // Use the range VALUE_TB to VALUE_TB_WIN_IN_MAX_PLY to score
                value = wdl < -drawScore ? -tbValue
                      : wdl > drawScore  ? tbValue
                                         : VALUE_DRAW + 2 * wdl * drawScore;

                Bound b = wdl < -drawScore ? BOUND_UPPER
                        : wdl > drawScore  ? BOUND_LOWER
                                           : BOUND_EXACT;

                if (b == BOUND_EXACT || (b == BOUND_LOWER ? value >= beta : value <= alpha))
                {
                    ttWriter.write(posKey, value_to_tt(value, ss->ply), ss->ttPv, b,
                                   std::min(MAX_PLY - 1, depth + 6), Move::none(), VALUE_NONE,
                                   tt.generation());

                    return value;
                }

                if (PvNode)
                {
                    if (b == BOUND_LOWER)
                        bestValue = value, alpha = std::max(alpha, bestValue);
                    else
                        maxValue = value;
                }
            }
        }
    }

    // Step 6. Static evaluation of the position
    Value      unadjustedStaticEval = VALUE_NONE;
    const auto correctionValue      = correction_value(*thisThread, pos, ss);
    if (ss->inCheck)
    {
        // Skip early pruning when in check
        ss->staticEval = eval = (ss - 2)->staticEval;
        improving             = false;
        goto moves_loop;
    }
    else if (excludedMove)
    {
        // Providing the hint that this node's accumulator will be used often
        unadjustedStaticEval = eval = ss->staticEval;
    }
    else if (ss->ttHit)
    {
        // Never assume anything about values stored in TT
        unadjustedStaticEval = ttData.eval;
        if (!is_valid(unadjustedStaticEval))
            unadjustedStaticEval = evaluate(pos);

        ss->staticEval = eval = to_corrected_static_eval(unadjustedStaticEval, correctionValue);

        // ttValue can be used as a better position evaluation
        if (is_valid(ttData.value)
            && (ttData.bound & (ttData.value > eval ? BOUND_LOWER : BOUND_UPPER)))
            eval = ttData.value;
    }
    else
    {
        unadjustedStaticEval = evaluate(pos);
        ss->staticEval = eval = to_corrected_static_eval(unadjustedStaticEval, correctionValue);

        // Static evaluation is saved as it was before adjustment by correction history
        ttWriter.write(posKey, VALUE_NONE, ss->ttPv, BOUND_NONE, DEPTH_UNSEARCHED, Move::none(),
                       unadjustedStaticEval, tt.generation());
    }

    // Use static evaluation difference to improve quiet move ordering
    if (((ss - 1)->currentMove).is_ok() && !(ss - 1)->inCheck && !priorCapture)
    {
        int bonus = std::clamp(-10 * int((ss - 1)->staticEval + ss->staticEval), -1906, 1450) + 638;
        thisThread->mainHistory[~us][((ss - 1)->currentMove).from_to()] << bonus * 1136 / 1024;
        if (type_of(pos.piece_on(prevSq)) != PAWN && ((ss - 1)->currentMove).type_of() != PROMOTION)
            thisThread->pawnHistory[pawn_structure_index(pos)][pos.piece_on(prevSq)][prevSq]
              << bonus * 1195 / 1024;
    }

    // Set up the improving flag, which is true if current static evaluation is
    // bigger than the previous static evaluation at our turn (if we were in
    // check at our previous move we go back until we weren't in check) and is
    // false otherwise. The improving flag is used in various pruning heuristics.
    improving = ss->staticEval > (ss - 2)->staticEval;

    opponentWorsening = ss->staticEval > -(ss - 1)->staticEval;

    if (priorReduction >= 3 && !opponentWorsening)
        depth++;
    if (priorReduction >= 1 && depth >= 2 && ss->staticEval + (ss - 1)->staticEval > 200)
        depth--;

    // Step 7. Razoring
    // If eval is really low, skip search entirely and return the qsearch value.
    // For PvNodes, we must have a guard against mates being returned.
    if (!PvNode && eval < alpha - 446 - 303 * depth * depth)
        return qsearch<NonPV>(pos, ss, alpha, beta);

    // Step 8. Futility pruning: child node
    // The depth condition is important for mate finding.
    if (!ss->ttPv && depth < 14
        && eval - futility_margin(depth, cutNode && !ss->ttHit, improving, opponentWorsening)
               - (ss - 1)->statScore / 326 + 37 - std::abs(correctionValue) / 132821
             >= beta
        && eval >= beta && (!ttData.move || ttCapture) && !is_loss(beta) && !is_win(eval))
        return beta + (eval - beta) / 3;

    // Step 9. Null move search with verification search
    if (cutNode && (ss - 1)->currentMove != Move::null() && eval >= beta
        && ss->staticEval >= beta - 21 * depth + 455 - 60 * improving && !excludedMove
        && pos.non_pawn_material(us) && ss->ply >= thisThread->nmpMinPly && !is_loss(beta))
    {
        assert(eval - beta >= 0);

        // Null move dynamic reduction based on depth and eval
        Depth R = std::min(int(eval - beta) / 237, 6) + depth / 3 + 5;

        ss->currentMove                   = Move::null();
        ss->continuationHistory           = &thisThread->continuationHistory[0][0][NO_PIECE][0];
        ss->continuationCorrectionHistory = &thisThread->continuationCorrectionHistory[NO_PIECE][0];

        pos.do_null_move(st, tt);

        Value nullValue = -search<NonPV>(pos, ss + 1, -beta, -beta + 1, depth - R, false);

        pos.undo_null_move();

        // Do not return unproven mate or TB scores
        if (nullValue >= beta && !is_win(nullValue))
        {
            if (thisThread->nmpMinPly || depth < 16)
                return nullValue;

            assert(!thisThread->nmpMinPly);  // Recursive verification is not allowed

            // Do verification search at high depths, with null move pruning disabled
            // until ply exceeds nmpMinPly.
            thisThread->nmpMinPly = ss->ply + 3 * (depth - R) / 4;

            Value v = search<NonPV>(pos, ss, beta - 1, beta, depth - R, false);

            thisThread->nmpMinPly = 0;

            if (v >= beta)
                return nullValue;
        }
    }

    improving |= ss->staticEval >= beta + 97;

    // Step 10. Internal iterative reductions
    // For PV nodes without a ttMove as well as for deep enough cutNodes, we decrease depth.
    // (* Scaler) Especially if they make IIR more aggressive.
    if (((PvNode || cutNode) && depth >= 7 - 3 * PvNode) && !ttData.move)
        depth--;

    // Step 11. ProbCut
    // If we have a good enough capture (or queen promotion) and a reduced search
    // returns a value much above beta, we can (almost) safely prune the previous move.
    probCutBeta = beta + 187 - 55 * improving;
    if (depth >= 3
        && !is_decisive(beta)
        // If value from transposition table is lower than probCutBeta, don't attempt
        // probCut there and in further interactions with transposition table cutoff
        // depth is set to depth - 3 because probCut search has depth set to depth - 4
        // but we also do a move before it. So effective depth is equal to depth - 3.
        && !(is_valid(ttData.value) && ttData.value < probCutBeta))
    {
        assert(probCutBeta < VALUE_INFINITE && probCutBeta > beta);

        MovePicker mp(pos, ttData.move, probCutBeta - ss->staticEval, &thisThread->captureHistory);
        Depth      probCutDepth = std::max(depth - 4, 0);

        while ((move = mp.next_move()) != Move::none())
        {
            assert(move.is_ok());

            if (move == excludedMove)
                continue;

            if (!pos.legal(move))
                continue;

            assert(pos.capture_stage(move));

            movedPiece = pos.moved_piece(move);

            pos.do_move(move, st, &tt);
            thisThread->nodes.fetch_add(1, std::memory_order_relaxed);

            ss->currentMove = move;
            ss->isTTMove    = (move == ttData.move);
            ss->continuationHistory =
              &this->continuationHistory[ss->inCheck][true][movedPiece][move.to_sq()];
            ss->continuationCorrectionHistory =
              &this->continuationCorrectionHistory[movedPiece][move.to_sq()];

            // Perform a preliminary qsearch to verify that the move holds
            value = -qsearch<NonPV>(pos, ss + 1, -probCutBeta, -probCutBeta + 1);

            // If the qsearch held, perform the regular search
            if (value >= probCutBeta && probCutDepth > 0)
                value = -search<NonPV>(pos, ss + 1, -probCutBeta, -probCutBeta + 1, probCutDepth,
                                       !cutNode);

            pos.undo_move(move);

            if (value >= probCutBeta)
            {
                // Save ProbCut data into transposition table
                ttWriter.write(posKey, value_to_tt(value, ss->ply), ss->ttPv, BOUND_LOWER,
                               probCutDepth + 1, move, unadjustedStaticEval, tt.generation());

                if (!is_decisive(value))
                    return value - (probCutBeta - beta);
            }
        }
    }

moves_loop:  // When in check, search starts here

    // Step 12. A small Probcut idea
    probCutBeta = beta + 413;
    if ((ttData.bound & BOUND_LOWER) && ttData.depth >= depth - 4 && ttData.value >= probCutBeta
        && !is_decisive(beta) && is_valid(ttData.value) && !is_decisive(ttData.value))
        return probCutBeta;

    const PieceToHistory* contHist[] = {
      (ss - 1)->continuationHistory, (ss - 2)->continuationHistory, (ss - 3)->continuationHistory,
      (ss - 4)->continuationHistory, (ss - 5)->continuationHistory, (ss - 6)->continuationHistory};


    MovePicker mp(pos, ttData.move, depth, &thisThread->mainHistory, &thisThread->lowPlyHistory,
                  &thisThread->captureHistory, contHist, &thisThread->pawnHistory, ss->ply);

    value = bestValue;

    int moveCount = 0;

    // Step 13. Loop through all pseudo-legal moves until no moves remain
    // or a beta cutoff occurs.
    while ((move = mp.next_move()) != Move::none())
    {
        assert(move.is_ok());

        if (move == excludedMove)
            continue;

        // Check for legality
        if (!pos.legal(move))
            continue;

        // At root obey the "searchmoves" option and skip moves not listed in Root
        // Move List. In MultiPV mode we also skip PV moves that have been already
        // searched and those of lower "TB rank" if we are in a TB root position.
        if (rootNode
            && !std::count(thisThread->rootMoves.begin() + thisThread->pvIdx,
                           thisThread->rootMoves.begin() + thisThread->pvLast, move))
            continue;

        ss->moveCount = ++moveCount;

        if (rootNode && is_mainthread() && nodes > 10000000)
        {
            main_manager()->updates.onIter(
              {depth, UCIEngine::move(move, pos.is_chess960()), moveCount + thisThread->pvIdx});
        }
        if (PvNode)
            (ss + 1)->pv = nullptr;

        extension  = 0;
        capture    = pos.capture_stage(move);
        movedPiece = pos.moved_piece(move);
        givesCheck = pos.gives_check(move);

        // Calculate new depth for this move
        newDepth = depth - 1;

        int delta = beta - alpha;

        Depth r = reduction(improving, depth, moveCount, delta);

        r -= 32 * moveCount;

        // Increase reduction for ttPv nodes (*Scaler)
        // Smaller or even negative value is better for short time controls
        // Bigger value is better for long time controls
        if (ss->ttPv)
            r += 1031;

        // Step 14. Pruning at shallow depth.
        // Depth conditions are important for mate finding.
        if (!rootNode && pos.non_pawn_material(us) && !is_loss(bestValue))
        {
            // Skip quiet moves if movecount exceeds our FutilityMoveCount threshold
            if (moveCount >= futility_move_count(improving, depth))
                mp.skip_quiet_moves();

            // Reduced depth of the next LMR search
            int lmrDepth = newDepth - r / 1024;

            if (capture || givesCheck)
            {
                Piece capturedPiece = pos.piece_on(move.to_sq());
                int   captHist =
                  thisThread->captureHistory[movedPiece][move.to_sq()][type_of(capturedPiece)];

                // Futility pruning for captures
                if (!givesCheck && lmrDepth < 7 && !ss->inCheck)
                {
                    Value futilityValue = ss->staticEval + 242 + 238 * lmrDepth
                                        + PieceValue[capturedPiece] + 95 * captHist / 700;
                    if (futilityValue <= alpha)
                        continue;
                }

                // SEE based pruning for captures and checks
                int seeHist = std::clamp(captHist / 36, -153 * depth, 134 * depth);
                if (!pos.see_ge(move, -157 * depth - seeHist))
                    continue;
            }
            else
            {
                int history =
                  (*contHist[0])[movedPiece][move.to_sq()]
                  + (*contHist[1])[movedPiece][move.to_sq()]
                  + thisThread->pawnHistory[pawn_structure_index(pos)][movedPiece][move.to_sq()];

                // Continuation history based pruning
                if (history < -4107 * depth)
                    continue;

                history += 68 * thisThread->mainHistory[us][move.from_to()] / 32;

                lmrDepth += history / 3576;

                Value futilityValue = ss->staticEval + (bestMove ? 49 : 143) + 116 * lmrDepth;

                if (bestValue < ss->staticEval - 150 && lmrDepth < 7)
                    futilityValue += 108;

                // Futility pruning: parent node
                // (*Scaler): Generally, more frequent futility pruning
                // scales well with respect to time and threads
                if (!ss->inCheck && lmrDepth < 12 && futilityValue <= alpha)
                {
                    if (bestValue <= futilityValue && !is_decisive(bestValue)
                        && !is_win(futilityValue))
                        bestValue = futilityValue;
                    continue;
                }

                lmrDepth = std::max(lmrDepth, 0);

                // Prune moves with negative SEE
                if (!pos.see_ge(move, -26 * lmrDepth * lmrDepth))
                    continue;
            }
        }

        // Step 15. Extensions
        // We take care to not overdo to avoid search getting stuck.
        if (ss->ply < thisThread->rootDepth * 2)
        {
            // Singular extension search. If all moves but one
            // fail low on a search of (alpha-s, beta-s), and just one fails high on
            // (alpha, beta), then that move is singular and should be extended. To
            // verify this we do a reduced search on the position excluding the ttMove
            // and if the result is lower than ttValue minus a margin, then we will
            // extend the ttMove. Recursive singular search is avoided.

            // (* Scaler) Generally, higher singularBeta (i.e closer to ttValue)
            // and lower extension margins scale well.

            if (!rootNode && move == ttData.move && !excludedMove
                && depth >= 5 - (thisThread->completedDepth > 32) + ss->ttPv
                && is_valid(ttData.value) && !is_decisive(ttData.value)
                && (ttData.bound & BOUND_LOWER) && ttData.depth >= depth - 3)
            {
                Value singularBeta  = ttData.value - (55 + 81 * (ss->ttPv && !PvNode)) * depth / 58;
                Depth singularDepth = newDepth / 2;

                ss->excludedMove = move;
                value =
                  search<NonPV>(pos, ss, singularBeta - 1, singularBeta, singularDepth, cutNode);
                ss->excludedMove = Move::none();

                if (value < singularBeta)
                {
                    int corrValAdj1  = std::abs(correctionValue) / 265083;
                    int corrValAdj2  = std::abs(correctionValue) / 253680;
                    int doubleMargin = 267 * PvNode - 181 * !ttCapture - corrValAdj1;
                    int tripleMargin =
                      96 + 282 * PvNode - 250 * !ttCapture + 103 * ss->ttPv - corrValAdj2;

                    extension = 1 + (value < singularBeta - doubleMargin)
                              + (value < singularBeta - tripleMargin);

                    depth++;
                }

                // Multi-cut pruning
                // Our ttMove is assumed to fail high based on the bound of the TT entry,
                // and if after excluding the ttMove with a reduced search we fail high
                // over the original beta, we assume this expected cut-node is not
                // singular (multiple moves fail high), and we can prune the whole
                // subtree by returning a softbound.
                else if (value >= beta && !is_decisive(value))
                    return value;

                // Negative extensions
                // If other moves failed high over (ttValue - margin) without the
                // ttMove on a reduced search, but we cannot do multi-cut because
                // (ttValue - margin) is lower than the original beta, we do not know
                // if the ttMove is singular or can do a multi-cut, so we reduce the
                // ttMove in favor of other moves based on some conditions:

                // If the ttMove is assumed to fail high over current beta
                else if (ttData.value >= beta)
                    extension = -3;

                // If we are on a cutNode but the ttMove is not assumed to fail high
                // over current beta
                else if (cutNode)
                    extension = -2;
            }
        }

        // Step 16. Make the move
        pos.do_move(move, st, givesCheck, &tt);
        thisThread->nodes.fetch_add(1, std::memory_order_relaxed);

        // Add extension to new depth
        newDepth += extension;

        // Update the current move (this must be done after singular extension search)
        ss->currentMove = move;
        ss->isTTMove    = (move == ttData.move);
        ss->continuationHistory =
          &thisThread->continuationHistory[ss->inCheck][capture][movedPiece][move.to_sq()];
        ss->continuationCorrectionHistory =
          &thisThread->continuationCorrectionHistory[movedPiece][move.to_sq()];
        uint64_t nodeCount = rootNode ? uint64_t(nodes) : 0;

        // Decrease reduction for PvNodes (*Scaler)
        if (ss->ttPv)
            r -= 2230 + PvNode * 1013 + (ttData.value > alpha) * 925
               + (ttData.depth >= depth) * (971 + cutNode * 1159);

        // These reduction adjustments have no proven non-linear scaling

        r += 316 - moveCount * 32;

        r -= std::abs(correctionValue) / 31568;

        if (PvNode && !is_decisive(bestValue))
            r -= risk_tolerance(pos, bestValue);

        // Increase reduction for cut nodes
        if (cutNode)
            r += 2608 + 1024 * !ttData.move;

        // Increase reduction if ttMove is a capture but the current move is not a capture
        if (ttCapture && !capture)
            r += 1123 + (depth < 8) * 982;

        // Increase reduction if next ply has a lot of fail high
        if ((ss + 1)->cutoffCnt > 3)
            r += 981 + allNode * 833;

        // For first picked move (ttMove) reduce reduction
        else if (move == ttData.move)
            r -= 1982;

        if (capture)
            ss->statScore =
              688 * int(PieceValue[pos.captured_piece()]) / 100
              + thisThread->captureHistory[movedPiece][move.to_sq()][type_of(pos.captured_piece())]
              - 4653;
        else
            ss->statScore = 2 * thisThread->mainHistory[us][move.from_to()]
                          + (*contHist[0])[movedPiece][move.to_sq()]
                          + (*contHist[1])[movedPiece][move.to_sq()] - 3591;

        // Decrease/increase reduction for moves with a good/bad history
        r -= ss->statScore * 1407 / 16384;

        // Step 17. Late moves reduction / extension (LMR)
        if (depth >= 2 && moveCount > 1)
        {
            // In general we want to cap the LMR depth search at newDepth, but when
            // reduction is negative, we allow this move a limited search extension
            // beyond the first move depth.
            // To prevent problems when the max value is less than the min value,
            // std::clamp has been replaced by a more robust implementation.


            Depth d = std::max(
              1, std::min(newDepth - r / 1024, newDepth + !allNode + (PvNode && !bestMove)));

            ss->reduction = newDepth - d;

            value         = -search<NonPV>(pos, ss + 1, -(alpha + 1), -alpha, d, true);
            ss->reduction = 0;


            // Do a full-depth search when reduced LMR search fails high
            if (value > alpha && d < newDepth)
            {
                // Adjust full-depth search based on LMR results - if the result was
                // good enough search deeper, if it was bad enough search shallower.
                const bool doDeeperSearch    = value > (bestValue + 41 + 2 * newDepth);
                const bool doShallowerSearch = value < bestValue + 9;

                newDepth += doDeeperSearch - doShallowerSearch;

                if (newDepth > d)
                    value = -search<NonPV>(pos, ss + 1, -(alpha + 1), -alpha, newDepth, !cutNode);

                // Post LMR continuation history updates
                int bonus = (value >= beta) * 2010;
                update_continuation_histories(ss, movedPiece, move.to_sq(), bonus);
            }
            else if (value > alpha && value < bestValue + 9)
                newDepth--;
        }

        // Step 18. Full-depth search when LMR is skipped
        else if (!PvNode || moveCount > 1)
        {
            // Increase reduction if ttMove is not present
            if (!ttData.move)
                r += 1111;

            // Note that if expected reduction is high, we reduce search depth here
            value = -search<NonPV>(pos, ss + 1, -(alpha + 1), -alpha,
                                   newDepth - (r > 3554) - (r > 5373 && newDepth > 2), !cutNode);
        }

        // For PV nodes only, do a full PV search on the first move or after a fail high,
        // otherwise let the parent node fail low with value <= alpha and try another move.
        if (PvNode && (moveCount == 1 || value > alpha))
        {
            (ss + 1)->pv    = pv;
            (ss + 1)->pv[0] = Move::none();

            // Extend move from transposition table if we are about to dive into qsearch.
            if (move == ttData.move && thisThread->rootDepth > 8)
                newDepth = std::max(newDepth, 1);

            value = -search<PV>(pos, ss + 1, -beta, -alpha, newDepth, false);
        }

        // Step 19. Undo move
        pos.undo_move(move);

        assert(value > -VALUE_INFINITE && value < VALUE_INFINITE);

        // Step 20. Check for a new best move
        // Finished searching the move. If a stop occurred, the return value of
        // the search cannot be trusted, and we return immediately without updating
        // best move, principal variation nor transposition table.
        if (threads.stop.load(std::memory_order_relaxed))
            return VALUE_ZERO;

        if (rootNode)
        {
            RootMove& rm =
              *std::find(thisThread->rootMoves.begin(), thisThread->rootMoves.end(), move);

            rm.effort += nodes - nodeCount;

            rm.averageScore =
              rm.averageScore != -VALUE_INFINITE ? (value + rm.averageScore) / 2 : value;

            rm.meanSquaredScore = rm.meanSquaredScore != -VALUE_INFINITE * VALUE_INFINITE
                                  ? (value * std::abs(value) + rm.meanSquaredScore) / 2
                                  : value * std::abs(value);

            // PV move or new best move?
            if (moveCount == 1 || value > alpha)
            {
                rm.score = rm.uciScore = value;
                rm.selDepth            = thisThread->selDepth;
                rm.scoreLowerbound = rm.scoreUpperbound = false;

                if (value >= beta)
                {
                    rm.scoreLowerbound = true;
                    rm.uciScore        = beta;
                }
                else if (value <= alpha)
                {
                    rm.scoreUpperbound = true;
                    rm.uciScore        = alpha;
                }

                rm.pv.resize(1);

                assert((ss + 1)->pv);

                for (Move* m = (ss + 1)->pv; *m != Move::none(); ++m)
                    rm.pv.push_back(*m);

                // We record how often the best move has been changed in each iteration.
                // This information is used for time management. In MultiPV mode,
                // we must take care to only do this for the first PV line.
                if (moveCount > 1 && !thisThread->pvIdx)
                    ++thisThread->bestMoveChanges;
            }
            else
                // All other moves but the PV, are set to the lowest value: this
                // is not a problem when sorting because the sort is stable and the
                // move position in the list is preserved - just the PV is pushed up.
                rm.score = -VALUE_INFINITE;
        }

        // In case we have an alternative move equal in eval to the current bestmove,
        // promote it to bestmove by pretending it just exceeds alpha (but not beta).
        int inc = (value == bestValue && ss->ply + 2 >= thisThread->rootDepth
                   && (int(nodes) & 15) == 0 && !is_win(std::abs(value) + 1));

        if (value + inc > bestValue)
        {
            bestValue = value;

            if (value + inc > alpha)
            {
                bestMove = move;

                if (PvNode && !rootNode)  // Update pv even in fail-high case
                    update_pv(ss->pv, move, (ss + 1)->pv);

                if (value >= beta)
                {
                    // (* Scaler) Especially if they make cutoffCnt increment more often.
                    ss->cutoffCnt += (extension < 2) || PvNode;
                    assert(value >= beta);  // Fail high
                    break;
                }
                else
                {
                    // Reduce other moves if we have found at least one score improvement
                    if (depth > 2 && depth < 15 && !is_decisive(value))
                        depth -= 2;

                    assert(depth > 0);
                    alpha = value;  // Update alpha! Always alpha < beta
                }
            }
        }

        // If the move is worse than some previously searched move,
        // remember it, to update its stats later.
        if (move != bestMove && moveCount <= 32)
        {
            if (capture)
                capturesSearched.push_back(move);
            else
                quietsSearched.push_back(move);
        }
    }

    // Step 21. Check for mate and stalemate
    // All legal moves have been searched and if there are no legal moves, it
    // must be a mate or a stalemate. If we are in a singular extension search then
    // return a fail low score.

    assert(moveCount || !ss->inCheck || excludedMove || !MoveList<LEGAL>(pos).size());

    // Adjust best value for fail high cases at non-pv nodes
    if (!PvNode && bestValue >= beta && !is_decisive(bestValue) && !is_decisive(beta)
        && !is_decisive(alpha))
        bestValue = (bestValue * depth + beta) / (depth + 1);

    if (!moveCount)
        bestValue = excludedMove ? alpha : ss->inCheck ? mated_in(ss->ply) : VALUE_DRAW;

    // If there is a move that produces search value greater than alpha,
    // we update the stats of searched moves.
    else if (bestMove)
        update_all_stats(pos, ss, *this, bestMove, prevSq, quietsSearched, capturesSearched, depth,
                         bestMove == ttData.move, moveCount);

    // Bonus for prior countermove that caused the fail low
    else if (!priorCapture && prevSq != SQ_NONE)
    {
        int bonusScale = (118 * (depth > 5) + 36 * !allNode + 161 * ((ss - 1)->moveCount > 8)
                          + 133 * (!ss->inCheck && bestValue <= ss->staticEval - 107)
                          + 120 * (!(ss - 1)->inCheck && bestValue <= -(ss - 1)->staticEval - 84)
                          + 81 * ((ss - 1)->isTTMove) + 100 * (ss->cutoffCnt <= 3)
                          + std::min(-(ss - 1)->statScore / 108, 320));

        bonusScale = std::max(bonusScale, 0);

        const int scaledBonus = std::min(160 * depth - 106, 1523) * bonusScale;

        update_continuation_histories(ss - 1, pos.piece_on(prevSq), prevSq,
                                      scaledBonus * 416 / 32768);

        thisThread->mainHistory[~us][((ss - 1)->currentMove).from_to()]
          << scaledBonus * 219 / 32768;

        if (type_of(pos.piece_on(prevSq)) != PAWN && ((ss - 1)->currentMove).type_of() != PROMOTION)
            thisThread->pawnHistory[pawn_structure_index(pos)][pos.piece_on(prevSq)][prevSq]
              << scaledBonus * 1103 / 32768;
    }

    else if (priorCapture && prevSq != SQ_NONE)
    {
        // bonus for prior countermoves that caused the fail low
        Piece capturedPiece = pos.captured_piece();
        assert(capturedPiece != NO_PIECE);
        thisThread->captureHistory[pos.piece_on(prevSq)][prevSq][type_of(capturedPiece)]
          << std::min(330 * depth - 198, 3320);
    }

    if (PvNode)
        bestValue = std::min(bestValue, maxValue);

    // If no good move is found and the previous position was ttPv, then the previous
    // opponent move is probably good and the new position is added to the search tree.
    if (bestValue <= alpha)
        ss->ttPv = ss->ttPv || (ss - 1)->ttPv;

    // Write gathered information in transposition table. Note that the
    // static evaluation is saved as it was before correction history.
    if (!excludedMove && !(rootNode && thisThread->pvIdx))
        ttWriter.write(posKey, value_to_tt(bestValue, ss->ply), ss->ttPv,
                       bestValue >= beta    ? BOUND_LOWER
                       : PvNode && bestMove ? BOUND_EXACT
                                            : BOUND_UPPER,
                       depth, bestMove, unadjustedStaticEval, tt.generation());

    // Adjust correction history
    if (!ss->inCheck && !(bestMove && pos.capture(bestMove))
        && ((bestValue < ss->staticEval && bestValue < beta)  // negative correction & no fail high
            || (bestValue > ss->staticEval && bestMove)))     // positive correction & no fail low
    {
        auto bonus = std::clamp(int(bestValue - ss->staticEval) * depth / 8,
                                -CORRECTION_HISTORY_LIMIT / 4, CORRECTION_HISTORY_LIMIT / 4);
        update_correction_history(pos, ss, *thisThread, bonus);
    }

    assert(bestValue > -VALUE_INFINITE && bestValue < VALUE_INFINITE);

    return bestValue;
}


// Quiescence search function, which is called by the main search function with
// depth zero, or recursively with further decreasing depth. With depth <= 0, we
// "should" be using static eval only, but tactical moves may confuse the static eval.
// To fight this horizon effect, we implement this qsearch of tactical moves.
// See https://www.chessprogramming.org/Horizon_Effect
// and https://www.chessprogramming.org/Quiescence_Search
template<NodeType nodeType>
Value Search::Worker::qsearch(Position& pos, Stack* ss, Value alpha, Value beta) {

    static_assert(nodeType != Root);
    constexpr bool PvNode = nodeType == PV;

    assert(alpha >= -VALUE_INFINITE && alpha < beta && beta <= VALUE_INFINITE);
    assert(PvNode || (alpha == beta - 1));

    // Check if we have an upcoming move that draws by repetition
    if (alpha < VALUE_DRAW && pos.upcoming_repetition(ss->ply))
    {
        alpha = value_draw(this->nodes);
        if (alpha >= beta)
            return alpha;
    }

    Move      pv[MAX_PLY + 1];
    StateInfo st;
    ASSERT_ALIGNED(&st, Eval::NNUE::CacheLineSize);

    Key   posKey;
    Move  move, bestMove;
    Value bestValue, value, futilityBase;
    bool  pvHit, givesCheck, capture;
    int   moveCount;

    // Step 1. Initialize node
    if (PvNode)
    {
        (ss + 1)->pv = pv;
        ss->pv[0]    = Move::none();
    }

    Worker* thisThread = this;
    bestMove           = Move::none();
    ss->inCheck        = pos.checkers();
    moveCount          = 0;

    // Used to send selDepth info to GUI (selDepth counts from 1, ply from 0)
    if (PvNode && thisThread->selDepth < ss->ply + 1)
        thisThread->selDepth = ss->ply + 1;

    // Step 2. Check for an immediate draw or maximum ply reached
    if (pos.is_draw(ss->ply) || ss->ply >= MAX_PLY)
        return (ss->ply >= MAX_PLY && !ss->inCheck) ? evaluate(pos) : VALUE_DRAW;

    assert(0 <= ss->ply && ss->ply < MAX_PLY);

    // Step 3. Transposition table lookup
    posKey                         = pos.key();
    auto [ttHit, ttData, ttWriter] = tt.probe(posKey);
    // Need further processing of the saved data
    ss->ttHit    = ttHit;
    ttData.move  = ttHit ? ttData.move : Move::none();
    ttData.value = ttHit ? value_from_tt(ttData.value, ss->ply, pos.rule50_count()) : VALUE_NONE;
    pvHit        = ttHit && ttData.is_pv;

    // At non-PV nodes we check for an early TT cutoff
    if (!PvNode && ttData.depth >= DEPTH_QS
        && is_valid(ttData.value)  // Can happen when !ttHit or when access race in probe()
        && (ttData.bound & (ttData.value >= beta ? BOUND_LOWER : BOUND_UPPER)))
        return ttData.value;

    // Step 4. Static evaluation of the position
    Value      unadjustedStaticEval = VALUE_NONE;
    const auto correctionValue      = correction_value(*thisThread, pos, ss);
    if (ss->inCheck)
        bestValue = futilityBase = -VALUE_INFINITE;
    else
    {
        if (ss->ttHit)
        {
            // Never assume anything about values stored in TT
            unadjustedStaticEval = ttData.eval;
            if (!is_valid(unadjustedStaticEval))
                unadjustedStaticEval = evaluate(pos);
            ss->staticEval = bestValue =
              to_corrected_static_eval(unadjustedStaticEval, correctionValue);

            // ttValue can be used as a better position evaluation
            if (is_valid(ttData.value) && !is_decisive(ttData.value)
                && (ttData.bound & (ttData.value > bestValue ? BOUND_LOWER : BOUND_UPPER)))
                bestValue = ttData.value;
        }
        else
        {
            // In case of null move search, use previous static eval with opposite sign
            unadjustedStaticEval =
              (ss - 1)->currentMove != Move::null() ? evaluate(pos) : -(ss - 1)->staticEval;
            ss->staticEval = bestValue =
              to_corrected_static_eval(unadjustedStaticEval, correctionValue);
        }

        // Stand pat. Return immediately if static value is at least beta
        if (bestValue >= beta)
        {
            if (!is_decisive(bestValue))
                bestValue = (bestValue + beta) / 2;
            if (!ss->ttHit)
                ttWriter.write(posKey, value_to_tt(bestValue, ss->ply), false, BOUND_LOWER,
                               DEPTH_UNSEARCHED, Move::none(), unadjustedStaticEval,
                               tt.generation());
            return bestValue;
        }

        if (bestValue > alpha)
            alpha = bestValue;

        futilityBase = ss->staticEval + 325;
    }

    const PieceToHistory* contHist[] = {(ss - 1)->continuationHistory,
                                        (ss - 2)->continuationHistory};

    Square prevSq = ((ss - 1)->currentMove).is_ok() ? ((ss - 1)->currentMove).to_sq() : SQ_NONE;

    // Initialize a MovePicker object for the current position, and prepare to search
    // the moves. We presently use two stages of move generator in quiescence search:
    // captures, or evasions only when in check.
    MovePicker mp(pos, ttData.move, DEPTH_QS, &thisThread->mainHistory, &thisThread->lowPlyHistory,
                  &thisThread->captureHistory, contHist, &thisThread->pawnHistory, ss->ply);

    // Step 5. Loop through all pseudo-legal moves until no moves remain or a beta
    // cutoff occurs.
    while ((move = mp.next_move()) != Move::none())
    {
        assert(move.is_ok());

        if (!pos.legal(move))
            continue;

        givesCheck = pos.gives_check(move);
        capture    = pos.capture_stage(move);

        moveCount++;

        // Step 6. Pruning
        if (!is_loss(bestValue))
        {
            // Futility pruning and moveCount pruning
            if (!givesCheck && move.to_sq() != prevSq && !is_loss(futilityBase)
                && move.type_of() != PROMOTION)
            {
                if (moveCount > 2)
                    continue;

                Value futilityValue = futilityBase + PieceValue[pos.piece_on(move.to_sq())];

                // If static eval + value of piece we are going to capture is
                // much lower than alpha, we can prune this move.
                if (futilityValue <= alpha)
                {
                    bestValue = std::max(bestValue, futilityValue);
                    continue;
                }

                // If static exchange evaluation is low enough
                // we can prune this move.
                if (!pos.see_ge(move, alpha - futilityBase))
                {
                    bestValue = std::min(alpha, futilityBase);
                    continue;
                }
            }

            // Continuation history based pruning
            if (!capture
                && (*contHist[0])[pos.moved_piece(move)][move.to_sq()]
                       + (*contHist[1])[pos.moved_piece(move)][move.to_sq()]
                       + thisThread->pawnHistory[pawn_structure_index(pos)][pos.moved_piece(move)]
                                                [move.to_sq()]
                     <= 5389)
                continue;

            // Do not search moves with bad enough SEE values
            if (!pos.see_ge(move, -75))
                continue;
        }

        // Step 7. Make and search the move
        Piece movedPiece = pos.moved_piece(move);

        pos.do_move(move, st, givesCheck, &tt);
        thisThread->nodes.fetch_add(1, std::memory_order_relaxed);

        // Update the current move
        ss->currentMove = move;
        ss->continuationHistory =
          &thisThread->continuationHistory[ss->inCheck][capture][movedPiece][move.to_sq()];
        ss->continuationCorrectionHistory =
          &thisThread->continuationCorrectionHistory[movedPiece][move.to_sq()];

        value = -qsearch<nodeType>(pos, ss + 1, -beta, -alpha);
        pos.undo_move(move);

        assert(value > -VALUE_INFINITE && value < VALUE_INFINITE);

        // Step 8. Check for a new best move
        if (value > bestValue)
        {
            bestValue = value;

            if (value > alpha)
            {
                bestMove = move;

                if (PvNode)  // Update pv even in fail-high case
                    update_pv(ss->pv, move, (ss + 1)->pv);

                if (value < beta)  // Update alpha here!
                    alpha = value;
                else
                    break;  // Fail high
            }
        }
    }

    // Step 9. Check for mate
    // All legal moves have been searched. A special case: if we are
    // in check and no legal moves were found, it is checkmate.
    if (ss->inCheck && bestValue == -VALUE_INFINITE)
    {
        assert(!MoveList<LEGAL>(pos).size());
        return mated_in(ss->ply);  // Plies to mate from the root
    }

    if (!is_decisive(bestValue) && bestValue > beta)
        bestValue = (bestValue + beta) / 2;

    // Save gathered info in transposition table. The static evaluation
    // is saved as it was before adjustment by correction history.
    ttWriter.write(posKey, value_to_tt(bestValue, ss->ply), pvHit,
                   bestValue >= beta ? BOUND_LOWER : BOUND_UPPER, DEPTH_QS, bestMove,
                   unadjustedStaticEval, tt.generation());

    assert(bestValue > -VALUE_INFINITE && bestValue < VALUE_INFINITE);

    return bestValue;
}

Depth Search::Worker::reduction(bool i, Depth d, int mn, int delta) const {
    int reductionScale = reductions[d] * reductions[mn];
    return reductionScale - delta * 735 / rootDelta + !i * reductionScale * 191 / 512 + 1132;
}

// elapsed() returns the time elapsed since the search started. If the
// 'nodestime' option is enabled, it will return the count of nodes searched
// instead. This function is called to check whether the search should be
// stopped based on predefined thresholds like time limits or nodes searched.
//
// elapsed_time() returns the actual time elapsed since the start of the search.
// This function is intended for use only when printing PV outputs, and not used
// for making decisions within the search algorithm itself.
TimePoint Search::Worker::elapsed() const {
    return main_manager()->tm.elapsed([this]() { return threads.nodes_searched(); });
}

TimePoint Search::Worker::elapsed_time() const { return main_manager()->tm.elapsed_time(); }

Value Search::Worker::evaluate(const Position& pos) {
    return Eval::evaluate(networks[numaAccessToken], pos, refreshTable,
                          optimism[pos.side_to_move()]);
}

namespace {
// Adjusts a mate or TB score from "plies to mate from the root" to
// "plies to mate from the current position". Standard scores are unchanged.
// The function is called before storing a value in the transposition table.
Value value_to_tt(Value v, int ply) { return is_win(v) ? v + ply : is_loss(v) ? v - ply : v; }


// Inverse of value_to_tt(): it adjusts a mate or TB score from the transposition
// table (which refers to the plies to mate/be mated from current position) to
// "plies to mate/be mated (TB win/loss) from the root". However, to avoid
// potentially false mate or TB scores related to the 50 moves rule and the
// graph history interaction, we return the highest non-TB score instead.
Value value_from_tt(Value v, int ply, int r50c) {

    if (!is_valid(v))
        return VALUE_NONE;

    // handle TB win or better
    if (is_win(v))
    {
        // Downgrade a potentially false mate score
        if (v >= VALUE_MATE_IN_MAX_PLY && VALUE_MATE - v > 100 - r50c)
            return VALUE_TB_WIN_IN_MAX_PLY - 1;

        // Downgrade a potentially false TB score.
        if (VALUE_TB - v > 100 - r50c)
            return VALUE_TB_WIN_IN_MAX_PLY - 1;

        return v - ply;
    }

    // handle TB loss or worse
    if (is_loss(v))
    {
        // Downgrade a potentially false mate score.
        if (v <= VALUE_MATED_IN_MAX_PLY && VALUE_MATE + v > 100 - r50c)
            return VALUE_TB_LOSS_IN_MAX_PLY + 1;

        // Downgrade a potentially false TB score.
        if (VALUE_TB + v > 100 - r50c)
            return VALUE_TB_LOSS_IN_MAX_PLY + 1;

        return v + ply;
    }

    return v;
}


// Adds current move and appends child pv[]
void update_pv(Move* pv, Move move, const Move* childPv) {

    for (*pv++ = move; childPv && *childPv != Move::none();)
        *pv++ = *childPv++;
    *pv = Move::none();
}


// Updates stats at the end of search() when a bestMove is found
void update_all_stats(const Position&      pos,
                      Stack*               ss,
                      Search::Worker&      workerThread,
                      Move                 bestMove,
                      Square               prevSq,
                      ValueList<Move, 32>& quietsSearched,
                      ValueList<Move, 32>& capturesSearched,
                      Depth                depth,
                      bool                 isTTMove,
                      int                  moveCount) {

    CapturePieceToHistory& captureHistory = workerThread.captureHistory;
    Piece                  moved_piece    = pos.moved_piece(bestMove);
    PieceType              captured;

    int bonus = std::min(162 * depth - 92, 1587) + 298 * isTTMove;
    int malus = std::min(694 * depth - 230, 2503) - 32 * (moveCount - 1);

    if (!pos.capture_stage(bestMove))
    {
        update_quiet_histories(pos, ss, workerThread, bestMove, bonus * 1202 / 1024);

        // Decrease stats for all non-best quiet moves
        for (Move move : quietsSearched)
            update_quiet_histories(pos, ss, workerThread, move, -malus * 1152 / 1024);
    }
    else
    {
        // Increase stats for the best move in case it was a capture move
        captured = type_of(pos.piece_on(bestMove.to_sq()));
        captureHistory[moved_piece][bestMove.to_sq()][captured] << bonus * 1236 / 1024;
    }

    // Extra penalty for a quiet early move that was not a TT move in
    // previous ply when it gets refuted.
    if (prevSq != SQ_NONE && ((ss - 1)->moveCount == 1 + (ss - 1)->ttHit) && !pos.captured_piece())
        update_continuation_histories(ss - 1, pos.piece_on(prevSq), prevSq, -malus * 976 / 1024);

    // Decrease stats for all non-best capture moves
    for (Move move : capturesSearched)
    {
        moved_piece = pos.moved_piece(move);
        captured    = type_of(pos.piece_on(move.to_sq()));
        captureHistory[moved_piece][move.to_sq()][captured] << -malus * 1224 / 1024;
    }
}


// Updates histories of the move pairs formed by moves
// at ply -1, -2, -3, -4, and -6 with current move.
void update_continuation_histories(Stack* ss, Piece pc, Square to, int bonus) {
    static constexpr std::array<ConthistBonus, 6> conthist_bonuses = {
      {{1, 1029}, {2, 656}, {3, 326}, {4, 536}, {5, 120}, {6, 537}}};

    for (const auto [i, weight] : conthist_bonuses)
    {
        // Only update the first 2 continuation histories if we are in check
        if (ss->inCheck && i > 2)
            break;
        if (((ss - i)->currentMove).is_ok())
            (*(ss - i)->continuationHistory)[pc][to] << bonus * weight / 1024;
    }
}

// Updates move sorting heuristics

void update_quiet_histories(
  const Position& pos, Stack* ss, Search::Worker& workerThread, Move move, int bonus) {

    Color us = pos.side_to_move();
    workerThread.mainHistory[us][move.from_to()] << bonus;  // Untuned to prevent duplicate effort

    if (ss->ply < LOW_PLY_HISTORY_SIZE)
        workerThread.lowPlyHistory[ss->ply][move.from_to()] << bonus * 844 / 1024;

    update_continuation_histories(ss, pos.moved_piece(move), move.to_sq(), bonus * 964 / 1024);

    int pIndex = pawn_structure_index(pos);
    workerThread.pawnHistory[pIndex][pos.moved_piece(move)][move.to_sq()] << bonus * 615 / 1024;
}

}

// When playing with strength handicap, choose the best move among a set of
// RootMoves using a statistical rule dependent on 'level'. Idea by Heinz van Saanen.
Move Skill::pick_best(const RootMoves& rootMoves, size_t multiPV) {
    static PRNG rng(now());  // PRNG sequence should be non-deterministic

    // RootMoves are already sorted by score in descending order
    Value  topScore = rootMoves[0].score;
    int    delta    = std::min(topScore - rootMoves[multiPV - 1].score, int(PawnValue));
    int    maxScore = -VALUE_INFINITE;
    double weakness = 120 - 2 * level;

    // Choose best move. For each move score we add two terms, both dependent on
    // weakness. One is deterministic and bigger for weaker levels, and one is
    // random. Then we choose the move with the resulting highest score.
    for (size_t i = 0; i < multiPV; ++i)
    {
        // This is our magic formula
        int push = (weakness * int(topScore - rootMoves[i].score)
                    + delta * (rng.rand<unsigned>() % int(weakness)))
                 / 128;

        if (rootMoves[i].score + push >= maxScore)
        {
            maxScore = rootMoves[i].score + push;
            best     = rootMoves[i].pv[0];
        }
    }

    return best;
}


// Used to print debug info and, more importantly, to detect
// when we are out of available time and thus stop the search.
void SearchManager::check_time(Search::Worker& worker) {
    if (--callsCnt > 0)
        return;

    // When using nodes, ensure checking rate is not lower than 0.1% of nodes
    callsCnt = worker.limits.nodes ? std::min(512, int(worker.limits.nodes / 1024)) : 512;

    static TimePoint lastInfoTime = now();

    TimePoint elapsed = tm.elapsed([&worker]() { return worker.threads.nodes_searched(); });
    TimePoint tick    = worker.limits.startTime + elapsed;

    if (tick - lastInfoTime >= 1000)
    {
        lastInfoTime = tick;
        dbg_print();
    }

    // We should not stop pondering until told so by the GUI
    if (ponder)
        return;

    if (
      // Later we rely on the fact that we can at least use the mainthread previous
      // root-search score and PV in a multithreaded environment to prove mated-in scores.
      worker.completedDepth >= 1
      && ((worker.limits.use_time_management() && (elapsed > tm.maximum() || stopOnPonderhit))
          || (worker.limits.movetime && elapsed >= worker.limits.movetime)
          || (worker.limits.nodes && worker.threads.nodes_searched() >= worker.limits.nodes)))
        worker.threads.stop = worker.threads.abortedSearch = true;
}

// Used to correct and extend PVs for moves that have a TB (but not a mate) score.
// Keeps the search based PV for as long as it is verified to maintain the game
// outcome, truncates afterwards. Finally, extends to mate the PV, providing a
// possible continuation (but not a proven mating line).
void syzygy_extend_pv(const OptionsMap&         options,
                      const Search::LimitsType& limits,
                      Position&                 pos,
                      RootMove&                 rootMove,
                      Value&                    v) {

    auto t_start      = std::chrono::steady_clock::now();
    int  moveOverhead = int(options["Move Overhead"]);
    bool rule50       = bool(options["Syzygy50MoveRule"]);

    // Do not use more than moveOverhead / 2 time, if time management is active
    auto time_abort = [&t_start, &moveOverhead, &limits]() -> bool {
        auto t_end = std::chrono::steady_clock::now();
        return limits.use_time_management()
            && 2 * std::chrono::duration<double, std::milli>(t_end - t_start).count()
                 > moveOverhead;
    };

    std::list<StateInfo> sts;

    // Step 0, do the rootMove, no correction allowed, as needed for MultiPV in TB.
    auto& stRoot = sts.emplace_back();
    pos.do_move(rootMove.pv[0], stRoot);
    int ply = 1;

    // Step 1, walk the PV to the last position in TB with correct decisive score
    while (size_t(ply) < rootMove.pv.size())
    {
        Move& pvMove = rootMove.pv[ply];

        RootMoves legalMoves;
        for (const auto& m : MoveList<LEGAL>(pos))
            legalMoves.emplace_back(m);

        Tablebases::Config config = Tablebases::rank_root_moves(options, pos, legalMoves);
        RootMove&          rm     = *std::find(legalMoves.begin(), legalMoves.end(), pvMove);

        if (legalMoves[0].tbRank != rm.tbRank)
            break;

        ply++;

        auto& st = sts.emplace_back();
        pos.do_move(pvMove, st);

        // Do not allow for repetitions or drawing moves along the PV in TB regime
        if (config.rootInTB && ((rule50 && pos.is_draw(ply)) || pos.is_repetition(ply)))
        {
            pos.undo_move(pvMove);
            ply--;
            break;
        }

        // Full PV shown will thus be validated and end in TB.
        // If we cannot validate the full PV in time, we do not show it.
        if (config.rootInTB && time_abort())
            break;
    }

    // Resize the PV to the correct part
    rootMove.pv.resize(ply);

    // Step 2, now extend the PV to mate, as if the user explored syzygy-tables.info
    // using top ranked moves (minimal DTZ), which gives optimal mates only for simple
    // endgames e.g. KRvK.
    while (!(rule50 && pos.is_draw(0)))
    {
        if (time_abort())
            break;

        RootMoves legalMoves;
        for (const auto& m : MoveList<LEGAL>(pos))
        {
            auto&     rm = legalMoves.emplace_back(m);
            StateInfo tmpSI;
            pos.do_move(m, tmpSI);
            // Give a score of each move to break DTZ ties restricting opponent mobility,
            // but not giving the opponent a capture.
            for (const auto& mOpp : MoveList<LEGAL>(pos))
                rm.tbRank -= pos.capture(mOpp) ? 100 : 1;
            pos.undo_move(m);
        }

        // Mate found
        if (legalMoves.size() == 0)
            break;

        // Sort moves according to their above assigned rank.
        // This will break ties for moves with equal DTZ in rank_root_moves.
        std::stable_sort(
          legalMoves.begin(), legalMoves.end(),
          [](const Search::RootMove& a, const Search::RootMove& b) { return a.tbRank > b.tbRank; });

        // The winning side tries to minimize DTZ, the losing side maximizes it
        Tablebases::Config config = Tablebases::rank_root_moves(options, pos, legalMoves, true);

        // If DTZ is not available we might not find a mate, so we bail out
        if (!config.rootInTB || config.cardinality > 0)
            break;

        ply++;

        Move& pvMove = legalMoves[0].pv[0];
        rootMove.pv.push_back(pvMove);
        auto& st = sts.emplace_back();
        pos.do_move(pvMove, st);
    }

    // Finding a draw in this function is an exceptional case, that cannot happen when rule50 is false or
    // during engine game play, since we have a winning score, and play correctly
    // with TB support. However, it can be that a position is draw due to the 50 move
    // rule if it has been been reached on the board with a non-optimal 50 move counter
    // (e.g. 8/8/6k1/3B4/3K4/4N3/8/8 w - - 54 106 ) which TB with dtz counter rounding
    // cannot always correctly rank. See also
    // https://github.com/official-stockfish/Stockfish/issues/5175#issuecomment-2058893495
    // We adjust the score to match the found PV. Note that a TB loss score can be
    // displayed if the engine did not find a drawing move yet, but eventually search
    // will figure it out (e.g. 1kq5/q2r4/5K2/8/8/8/8/7Q w - - 96 1 )
    if (pos.is_draw(0))
        v = VALUE_DRAW;

    // Undo the PV moves
    for (auto it = rootMove.pv.rbegin(); it != rootMove.pv.rend(); ++it)
        pos.undo_move(*it);

    // Inform if we couldn't get a full extension in time
    if (time_abort())
        sync_cout
          << "info string Syzygy based PV extension requires more time, increase Move Overhead as needed."
          << sync_endl;
}

void SearchManager::pv(Search::Worker&           worker,
                       const ThreadPool&         threads,
                       const TranspositionTable& tt,
                       Depth                     depth) {

    const auto nodes     = threads.nodes_searched();
    auto&      rootMoves = worker.rootMoves;
    auto&      pos       = worker.rootPos;
    size_t     pvIdx     = worker.pvIdx;
    size_t     multiPV   = std::min(size_t(worker.options["MultiPV"]), rootMoves.size());
    uint64_t   tbHits    = threads.tb_hits() + (worker.tbConfig.rootInTB ? rootMoves.size() : 0);

    for (size_t i = 0; i < multiPV; ++i)
    {
        bool updated = rootMoves[i].score != -VALUE_INFINITE;

        if (depth == 1 && !updated && i > 0)
            continue;

        Depth d = updated ? depth : std::max(1, depth - 1);
        Value v = updated ? rootMoves[i].uciScore : rootMoves[i].previousScore;

        if (v == -VALUE_INFINITE)
            v = VALUE_ZERO;

        bool tb = worker.tbConfig.rootInTB && std::abs(v) <= VALUE_TB;
        v       = tb ? rootMoves[i].tbScore : v;

        bool isExact = i != pvIdx || tb || !updated;  // tablebase- and previous-scores are exact

        // Potentially correct and extend the PV, and in exceptional cases v
        if (is_decisive(v) && std::abs(v) < VALUE_MATE_IN_MAX_PLY
            && ((!rootMoves[i].scoreLowerbound && !rootMoves[i].scoreUpperbound) || isExact))
            syzygy_extend_pv(worker.options, worker.limits, pos, rootMoves[i], v);

        std::string pv;
        for (Move m : rootMoves[i].pv)
            pv += UCIEngine::move(m, pos.is_chess960()) + " ";

        // Remove last whitespace
        if (!pv.empty())
            pv.pop_back();

        auto wdl   = worker.options["UCI_ShowWDL"] ? UCIEngine::wdl(v, pos) : "";
        auto bound = rootMoves[i].scoreLowerbound
                     ? "lowerbound"
                     : (rootMoves[i].scoreUpperbound ? "upperbound" : "");

        InfoFull info;

        info.depth    = d;
        info.selDepth = rootMoves[i].selDepth;
        info.multiPV  = i + 1;
        info.score    = {v, pos};
        info.wdl      = wdl;

        if (!isExact)
            info.bound = bound;

        TimePoint time = std::max(TimePoint(1), tm.elapsed_time());
        info.timeMs    = time;
        info.nodes     = nodes;
        info.nps       = nodes * 1000 / time;
        info.tbHits    = tbHits;
        info.pv        = pv;
        info.hashfull  = tt.hashfull();

        updates.onUpdateFull(info);
    }
}

// Called in case we have no ponder move before exiting the search,
// for instance, in case we stop the search during a fail high at root.
// We try hard to have a ponder move to return to the GUI,
// otherwise in case of 'ponder on' we have nothing to think about.
bool RootMove::extract_ponder_from_tt(const TranspositionTable& tt, Position& pos) {

    StateInfo st;
    ASSERT_ALIGNED(&st, Eval::NNUE::CacheLineSize);

    assert(pv.size() == 1);
    if (pv[0] == Move::none())
        return false;

    pos.do_move(pv[0], st, &tt);

    auto [ttHit, ttData, ttWriter] = tt.probe(pos.key());
    if (ttHit)
    {
        if (MoveList<LEGAL>(pos).contains(ttData.move))
            pv.push_back(ttData.move);
    }

    pos.undo_move(pv[0]);
    return pv.size() > 1;
}


}  // namespace Stockfish
